<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker容器化技术</title>
      <link href="/2021/11/18/docker-rong-qi-hua-ji-zhu/"/>
      <url>/2021/11/18/docker-rong-qi-hua-ji-zhu/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h5 id="初识Docker"><a href="#初识Docker" class="headerlink" title="初识Docker"></a>初识Docker</h5><ul><li>Docker 是一个开源的应用容器引擎</li><li> 诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）</li><li> Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。 • 容器是完全使用沙箱机制，相互隔离 </li><li> 容器性能开销极低。 </li><li>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版</li><li>docker是一种容器化技术，用来解决软件跨平台迁移的问题</li></ul><h5 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h5><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># 1、yum 包更新到最新 yum update# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2# 3、 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo#阿里源yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo#无法配置yum源：yum -y install yum-utils # 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce# 5、 查看docker版本，验证是否验证成功docker -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>失败了。。。。，祭出以前的虚拟机Ubuntu</p><p>又失败了，下载CentOS 7:<a href="https://blog.csdn.net/qq_38789941/article/details/102499618">https://blog.csdn.net/qq_38789941/article/details/102499618</a></p><p>安装过程：<a href="https://blog.csdn.net/qq_44714603/article/details/88829423">https://blog.csdn.net/qq_44714603/article/details/88829423</a></p><p>配置网络：<a href="https://www.cnblogs.com/yhongji/p/9336247.html">https://www.cnblogs.com/yhongji/p/9336247.html</a></p><p><strong>配置镜像加速</strong></p><p>​    登录阿里云控制台搜索镜像加速器，配置(每人不一样)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  "registry-mirrors": ["https://vyeg89u1.mirror.aliyuncs.com"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h5><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是 一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包 含了完整的一套 Ubuntu16.04 最小系统的 root 文件系 统。 </li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Contain er）的关系，就像是面向对象程序设计中的类和对象一 样，镜像是静态的定义，容器是镜像运行时的实体。容 器可以被创建、启动、停止、删除、暂停等。 </li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心， 用来保存镜像</li></ul><p><img src="/2021/11/18/docker-rong-qi-hua-ji-zhu/image-20211118161201747.png" alt="docker架构"></p><h3 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h3><h5 id="1-docker进程相关命令："><a href="#1-docker进程相关命令：" class="headerlink" title="1.docker进程相关命令："></a>1.docker进程相关命令：</h5><ul><li><p>启动docker服务: </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl start docker <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 停止docker服务: </p></li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl stop docker <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 重启docker服务:</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl restart docker <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看docker服务状态:</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl status docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 设置开机启动docker服务:</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl enable docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-docker镜像相关命令："><a href="#2-docker镜像相关命令：" class="headerlink" title="2.docker镜像相关命令："></a>2.docker镜像相关命令：</h5><ul><li> 查看镜像: 查看本地所有的镜像:</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker imagesdocker images –q # 查看所用镜像的id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li> 搜索镜像:从网络中查找需要的镜像</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker search 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>拉取镜像:从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。 如果不知道镜像版本，可以去docker hub 搜索对应镜像查看</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker pull 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 删除镜像: 删除本地镜像</p></li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker rmi 镜像id # 删除指定本地镜像docker rmi `docker images -q` # 删除所有本地镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-docker容器相关命令："><a href="#3-docker容器相关命令：" class="headerlink" title="3.docker容器相关命令："></a>3.docker容器相关命令：</h5><ul><li> 查看容器</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker ps # 查看正在运行的容器docker ps –a # 查看所有容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><p>创建并启动容器</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run 参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数说明：</strong></p><ul><li>  -i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。 </li><li> -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。 </li><li> -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。 </li><li> -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器 </li><li> –name：为创建的容器命名。</li></ul></li><li><p>进入容器</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker exec 参数 # 退出容器，容器不会关闭<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>停止容器</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker stop 容器名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>启动容器</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker start 容器名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除</p></li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker rm 容器名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li> 查看容器信息</li></ul>  <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker inspect 容器名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Docker容器的数据卷"><a href="#Docker容器的数据卷" class="headerlink" title="Docker容器的数据卷"></a>Docker容器的数据卷</h3><h5 id="1-数据卷概念"><a href="#1-数据卷概念" class="headerlink" title="1.数据卷概念"></a>1.数据卷概念</h5><p><strong>思考：</strong></p><ul><li>Docker 容器删除后，在容器中产生的数据也会随之销毁</li><li>Docker 容器和外部机器可以直接交换文件吗？ </li><li>容器之间想要进行数据交互？</li></ul><p><strong>数据卷：</strong></p><ul><li>数据卷是宿主机中的一个目录或文件 </li><li>当容器目录和数据卷目录绑定后，对方的修改会立即同步 </li><li> 一个数据卷可以被多个容器同时挂载 </li><li>一个容器也可以被挂载多个数据卷</li></ul><p><strong>数据卷作用：</strong></p><ul><li>容器数据持久化 </li><li>外部机器和容器间接通信 </li><li>容器之间数据交换</li></ul><p><img src="/2021/11/18/docker-rong-qi-hua-ji-zhu/image-20211119134910130.png" alt="数据卷图"></p><h5 id="2-配置数据卷"><a href="#2-配置数据卷" class="headerlink" title="2.配置数据卷"></a>2.配置数据卷</h5><ul><li> 创建启动容器时，使用 –v 参数 设置数据卷</li></ul>  <pre class="line-numbers language-SH" data-language="SH"><code class="language-SH">docker run ... –v 宿主机目录(文件):容器内目录(文件) ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>注意事项</p><ul><li>. 目录必须是绝对路径</li><li>  如果目录不存在，会自动创建 </li><li> 可以挂载多个数据卷</li></ul></li></ul><h5 id="3-数据卷容器："><a href="#3-数据卷容器：" class="headerlink" title="3.数据卷容器："></a>3.数据卷容器：</h5><p>​    多容器进行数据交换 </p><p><img src="/2021/11/18/docker-rong-qi-hua-ji-zhu/image-20211119141816971.png" alt="数据卷容器"></p><ol><li> 多个容器挂载同一个数据卷 </li><li>数据卷容器</li></ol><h5 id="4-配置数据卷容器"><a href="#4-配置数据卷容器" class="headerlink" title="4.配置数据卷容器"></a>4.配置数据卷容器</h5><ol><li><p>创建启动c3数据卷容器，使用 –v 参数 设置数据卷 </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run –it --name=c3 –v /volume centos:7 /bin/bash  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建启动 c1 c2 容器，使用 –-volumes-from 参数 设置数据卷 </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h5 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h5><ol><li><p>数据卷概念<br>• 宿主机的一个目录或文件 </p></li><li><p> 数据卷作用 </p></li></ol><p>   • 容器数据持久化<br>   • 客户端和容器数据交换<br>   • 容器间数据交换 </p><ol start="3"><li>数据卷容器<br>• 创建一个容器，挂载一个目录，让其他容器继承自该容器( –volume-from )。<br>• 通过简单方式实现数据卷配置</li></ol><h3 id="Docker应用部署"><a href="#Docker应用部署" class="headerlink" title="Docker应用部署"></a>Docker应用部署</h3><h5 id="1-MySQL部署"><a href="#1-MySQL部署" class="headerlink" title="1.MySQL部署"></a>1.MySQL部署</h5><p><strong>需求：</strong>在Docker容器中部署MySQL，并通过外部mysql客户端操作MySQL Server</p><p><strong>实现步骤：</strong></p><ol><li>搜索mysql镜像</li><li>拉取mysql镜像</li><li> 创建容器 </li><li>操作容器中的mysql</li></ol><p><strong>注意：</strong></p><ul><li>  容器内的网络服务和外部机器不能直接通信 </li><li> 外部机器和宿主机可以直接通信 </li><li> 宿主机和容器可以直接通信 </li><li> 当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机 器访问宿主机的该端口，从而间接访问容器的服务。 </li><li>这种操作称为：<strong>端口映射</strong></li></ul><h6 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h6><ol><li>搜索mysql镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>拉取mysql镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull mysql:5.6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在/root目录下创建mysql目录用于存储mysql数据信息mkdir ~/mysqlcd ~/mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -id \-p 3307:3306 \--name=c_mysql \-v $PWD/conf:/etc/mysql/conf.d \-v $PWD/logs:/logs \-v $PWD/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \mysql:5.6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数说明：<ul><li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307端口。</li><li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</li><li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</li><li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul></li></ul><ol start="4"><li>进入容器，操作mysql</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker exec –it c_mysql /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="5"><li>使用外部机器连接容器中的mysql</li></ol><p><img src="/2021/11/18/docker-rong-qi-hua-ji-zhu/1573636765632.png" alt="1573636765632"></p><p><strong>扩展</strong></p><ul><li><p>查看防火墙状态</p></li><li><p>```<br>firewall-cmd –state</p><pre class="line-numbers language-none"><code class="language-none">- 停止firewall- ```  systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>禁止firewall开机启动</p></li><li><p>```<br>systemctl disable firewalld.service</p><pre class="line-numbers language-none"><code class="language-none">##### 2.tomcat部署1. 搜索tomcat镜像```shelldocker search tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ol start="2"><li>拉取tomcat镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在/root目录下创建tomcat目录用于存储tomcat数据信息mkdir ~/tomcatcd ~/tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -id --name=c_tomcat \-p 8080:8080 \-v $PWD:/usr/local/tomcat/webapps \tomcat <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>参数说明：</p><ul><li><p><strong>-p 8080:8080：</strong>将容器的8080端口映射到主机的8080端口</p><p><strong>-v $PWD:/usr/local/tomcat/webapps：</strong>将主机中当前目录挂载到容器的webapps</p></li></ul></li></ul><ol start="4"><li>使用外部机器访问tomcat</li></ol><h5 id="3-Nignx部署"><a href="#3-Nignx部署" class="headerlink" title="3.Nignx部署"></a>3.Nignx部署</h5><ol><li>搜索nginx镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>拉取nginx镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>创建容器，设置端口映射、目录映射</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在/root目录下创建nginx目录用于存储nginx数据信息mkdir ~/nginxcd ~/nginxmkdir confcd conf# 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容vim nginx.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                      '$status $body_bytes_sent "$http_referer" '                      '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -id --name=c_nginx \-p 80:80 \-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \-v $PWD/logs:/var/log/nginx \-v $PWD/html:/usr/share/nginx/html \nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>参数说明：<ul><li><strong>-p 80:80</strong>：将容器的 80端口映射到宿主机的 80 端口。</li><li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf。配置目录</li><li><strong>-v $PWD/logs:/var/log/nginx</strong>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx。日志目录</li></ul></li></ul><ol start="4"><li>使用外部机器访问nginx</li></ol><h5 id="4-reids部署"><a href="#4-reids部署" class="headerlink" title="4.reids部署"></a>4.reids部署</h5><ol><li>搜索redis镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>拉取redis镜像</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull redis:5.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>创建容器，设置端口映射</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker run -id --name=c_redis -p 6379:6379 redis:5.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>使用外部机器连接redis</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./redis-cli.exe -h 192.168.149.135 -p 6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><h5 id="1-docker镜像原理"><a href="#1-docker镜像原理" class="headerlink" title="1.docker镜像原理"></a>1.docker镜像原理</h5><p><strong>思考：</strong></p><ol><li>Docker 镜像本质是什么？<br>• 是一个分层文件系统 </li><li><ol start="2"><li>Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？<br>• Centos的iso镜像文件包含bootfs和rootfs，而docker的centos镜像复用操作系统的bootfs，只有rootfs和其他镜像层 </li></ol></li><li>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？<br>• 由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的 tomcat镜像大小500多MB</li></ol><p><strong>操作系统组成部分</strong></p><p> •进程调度子系统 </p><p>• 进程通信子系统 </p><p>• 内存管理子系统 </p><p>• 设备管理子系统 </p><p><strong>• 文件管理子系统</strong> </p><p>• 网络通信子系统 </p><p>• 作业控制子系统 </p><p>Linux文件系统由bootfs和rootfs两部分组成 </p><p>• bootfs：包含bootloader（引导加载程序）和 kernel（内核） </p><p>• rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev， /proc，/bin，/etc等标准目录和文件 • 不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu ，centos等</p><p><img src="/2021/11/18/docker-rong-qi-hua-ji-zhu/image-20211119151253233.png" alt="镜像原理"></p><h5 id="2-docker镜像制作"><a href="#2-docker镜像制作" class="headerlink" title="2.docker镜像制作"></a>2.docker镜像制作</h5><ol><li><p>容器转为镜像</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker commit 容器id 镜像名称:版本号docker save -o 压缩文件名称 镜像名称:版本号docker load –i 压缩文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>dockerfile</p></li></ol><h5 id="3-dockerfile概念"><a href="#3-dockerfile概念" class="headerlink" title="3.dockerfile概念"></a>3.dockerfile概念</h5><p>• Dockerfile 是一个文本文件 </p><p>• 包含了一条条的指令 </p><p>• 每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像 </p><p>• 对于开发人员：可以为开发团队提供一个完全一致的开发环境 </p><p>• 对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件 构建一个新的镜像开始工作了 </p><p>• 对于运维人员：在部署时，可以实现应用的无缝移值</p><h5 id="4-dockerfile关键字"><a href="#4-dockerfile关键字" class="headerlink" title="4.dockerfile关键字"></a>4.dockerfile关键字</h5><table><thead><tr><th>关键字</th><th>作用</th><th align="center">备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td align="center">指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td align="center">用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td align="center">用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td align="center">执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td align="center">提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td align="center">一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td align="center">build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td align="center">build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td align="center">指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td></tr><tr><td>ARG</td><td>构建参数</td><td align="center">构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td align="center">指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td align="center">定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td align="center">指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td align="center">指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td align="center">指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td align="center">当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td align="center">该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td align="center">指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table><h3 id="docke服务编排"><a href="#docke服务编排" class="headerlink" title="docke服务编排"></a>docke服务编排</h3><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停 ，维护的工作量会很大。 </p><p>• 要从Dockerfile build image 或者去dockerhub拉取image </p><p>• 要创建多个container </p><p>• 要管理这些container（启动停止删除）</p><p><strong>服务编排</strong>： 按照一定<strong>的业务规则批量管理容器</strong></p><h5 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a><strong>docker compose</strong></h5><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建 ，启动和停止。</p><p>使用步骤： </p><ol><li>利用 Dockerfile 定义运行环境镜像 </li><li>使用 docker-compose.yml 定义组成应用的各服务</li><li>运行 docker-compose up 启动应用</li></ol><h5 id="docker-compose-安装和使用"><a href="#docker-compose-安装和使用" class="headerlink" title="docker compose 安装和使用"></a>docker compose 安装和使用</h5><h6 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose# 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose# 查看版本信息 docker-compose -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="二、卸载Docker-Compose"><a href="#二、卸载Docker-Compose" class="headerlink" title="二、卸载Docker Compose"></a>二、卸载Docker Compose</h6><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 二进制包方式安装的，删除二进制文件即可rm /usr/local/bin/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="三、-使用docker-compose编排nginx-springboot项目"><a href="#三、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="三、 使用docker compose编排nginx+springboot项目"></a>三、 使用docker compose编排nginx+springboot项目</h6><ol><li>创建docker-compose目录</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir ~/docker-composecd ~/docker-compose<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>编写 docker-compose.yml 文件</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">version: '3'services:  nginx:   image: nginx   ports:    - 80:80   links:    - app   volumes:    - ./nginx/conf.d:/etc/nginx/conf.d  app:    image: app    expose:      - "8080"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建./nginx/conf.d目录</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir -p ./nginx/conf.d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="4"><li>在./nginx/conf.d目录下 编写itheima.conf文件</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">server {    listen 80;    access_log off;    location / {        proxy_pass http://app:8080;    }   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>在~/docker-compose 目录下 使用docker-compose 启动容器</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker-compose up<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>测试访问</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">http://192.168.149.135/hello<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h3><h5 id="一、私有仓库搭建"><a href="#一、私有仓库搭建" class="headerlink" title="一、私有仓库搭建"></a>一、私有仓库搭建</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、拉取私有仓库镜像 docker pull registry# 2、启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry# 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到{"repositories":[]} 表示私有仓库 搭建成功# 4、修改daemon.json &nbsp; vim /etc/docker/daemon.json &nbsp; &nbsp;# 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip {"insecure-registries":["私有仓库服务器ip:5000"]} # 5、重启docker 服务 systemctl restart dockerdocker start registry<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="二、将镜像上传至私有仓库"><a href="#二、将镜像上传至私有仓库" class="headerlink" title="二、将镜像上传至私有仓库"></a>二、将镜像上传至私有仓库</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 1、标记镜像为私有仓库的镜像 &nbsp; &nbsp; docker tag centos:7 私有仓库服务器IP:5000/centos:7 # 2、上传标记的镜像 &nbsp; &nbsp; docker push 私有仓库服务器IP:5000/centos:7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="三、-从私有仓库拉取镜像"><a href="#三、-从私有仓库拉取镜像" class="headerlink" title="三、 从私有仓库拉取镜像"></a>三、 从私有仓库拉取镜像</h5><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#拉取镜像 docker pull 私有仓库服务器ip:5000/centos:7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2021/11/18/rabbitmq/"/>
      <url>/2021/11/18/rabbitmq/</url>
      
        <content type="html"><![CDATA[<h3 id="1-MQ的基本概念"><a href="#1-MQ的基本概念" class="headerlink" title="1.MQ的基本概念"></a>1.MQ的基本概念</h3><h5 id="1-1MQ概述"><a href="#1-1MQ概述" class="headerlink" title="1.1MQ概述"></a>1.1MQ概述</h5><p>​    MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进 行通信。</p><p><img src="/2021/11/18/rabbitmq/image-20211118142124977.png" alt="直接调用"></p><p><img src="/2021/11/18/rabbitmq/image-20211118142151441.png" alt="第三方调用"></p><h5 id="1-2MQ的优势与劣势"><a href="#1-2MQ的优势与劣势" class="headerlink" title="1.2MQ的优势与劣势"></a>1.2MQ的优势与劣势</h5><h6 id="1-2-1优势"><a href="#1-2-1优势" class="headerlink" title="1.2.1优势"></a>1.2.1优势</h6><ol><li>应用解耦：<br><img src="/2021/11/18/rabbitmq/image-20211118142551346.png" alt="应用解耦"></li><li>异步提速<br><img src="/2021/11/18/rabbitmq/image-20211118142722124.png" alt="异步提速"></li><li>削峰填谷<br><img src="/2021/11/18/rabbitmq/image-20211118143133960.png" alt="削峰填谷"></li></ol><p><img src="/2021/11/18/rabbitmq/image-20211118143214365.png" alt="削峰填谷2"></p><p>​    使用了 MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰 就被“削”掉了，但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直 到消费完积压的消息，这就叫做“填谷”。</p><p><strong>使用MQ后，可以提高系统稳定性。</strong></p><h6 id="1-2-2劣势"><a href="#1-2-2劣势" class="headerlink" title="1.2.2劣势"></a>1.2.2劣势</h6><ol><li><p>系统可用性降低<br> 系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响</p></li><li><p>如何保证MQ的高可用？<br>系统复杂度提高 MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何 保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？ </p></li><li><p>一致性问题<br>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理 失败。如何保证消息数据处理的一致性？</p><p>既然 MQ 有优势也有劣势，那么<strong>使用 MQ 需要满足什么条件呢</strong>？</p></li></ol><ul><li>生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明 明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。 </li><li>容许短暂的不一致性。</li><li> 确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</li></ul><h5 id="1-3常见的MQ产品"><a href="#1-3常见的MQ产品" class="headerlink" title="1.3常见的MQ产品"></a>1.3常见的MQ产品</h5><p><img src="/2021/11/18/rabbitmq/image-20211118143922036.png" alt="MQ产品对比"></p><h3 id="2-RabbitMQ"><a href="#2-RabbitMQ" class="headerlink" title="2.RabbitMQ"></a>2.RabbitMQ</h3><h5 id="2-1RabbitMQ-简介"><a href="#2-1RabbitMQ-简介" class="headerlink" title="2.1RabbitMQ 简介"></a>2.1RabbitMQ 简介</h5><h6 id="2-1-1AMQP协议"><a href="#2-1-1AMQP协议" class="headerlink" title="2.1.1AMQP协议"></a>2.1.1AMQP协议</h6><p>​        <strong>AMQP，即 Advanced Message Queuing Protocol（高级消息队列协议）</strong>，是一个网络协议，是应用层协议 的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中 间件不同产品，不同的开发语言等条件的限制。2006年，AMQP 规范发布。<strong>类比HTTP。</strong></p><p><img src="/2021/11/18/rabbitmq/image-20211118144502541.png" alt="AMQP结构"></p><h6 id="2-1-2RabbitMQ介绍"><a href="#2-1-2RabbitMQ介绍" class="headerlink" title="2.1.2RabbitMQ介绍"></a>2.1.2RabbitMQ介绍</h6><p>​    2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。 Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><p>RabbitMQ 基础架构如下图</p><p><img src="/2021/11/18/rabbitmq/image-20211118144612213.png" alt="RabbitMQ基础架构"></p><p>2.1.3RabbitMQ中的相关概念</p><ul><li><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</li><li> <strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网 络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多 个vhost，每个用户在自己的 vhost 创建 exchange／queue 等</li><li> <strong>Connection</strong>：publisher／consumer 和 broker 之间的 TCP 连接 </li><li> <strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线 程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection  极大减少了操作系统建立 TCP connection 的开销</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast) </li><li><strong>Queue</strong>：消息最终被送到这里等待 consumer 取走 </li><li><strong>Binding</strong>：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存 到 exchange 中的查询表中，用于 message 的分发依据</li></ul><p><strong>RabbitMQ 提供了 6 种工作模式</strong>：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。</p><p><img src="/2021/11/18/rabbitmq/image-20211118145344241.png" alt="工作模式"></p><p><strong>JMS</strong>:</p><ul><li> JMS 即 Java 消息服务（JavaMessage Service）应用程序接口，是一个 Java 平台中关于面向消息中间件 的API </li><li>JMS 是 JavaEE 规范中的一种，类比JDBC</li><li> 很多消息中间件都实现了JMS规范，例如：ActiveMQ。RabbitMQ 官方没有提供 JMS 的实现包，但是开 源社区有 </li></ul><p><strong>小结：</strong></p><ul><li>RabbitMQ 是基于 AMQP 协议使用 Erlang 语言开发的一款消息队列产品。</li><li>RabbitMQ提供了6种工作模式，我们学习5种。这是今天的重点。</li><li>AMQP 是协议，类比HTTP。</li><li>  JMS 是 API 规范接口，类比 JDBC。</li></ul><h5 id="2-2安装RabbitMQ"><a href="#2-2安装RabbitMQ" class="headerlink" title="2.2安装RabbitMQ"></a>2.2安装RabbitMQ</h5><p>​    在线安装依赖环境：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>问题：yum 无法使用</p><p>解决</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">1.sed -i "s|enabled=1|enabled=0|g" /etc/yum/pluginconf.d/fastestmirror.conf2.mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup3.curl -o /etc/yum.repos.d/CentOS-Base.repo https://www.xmpan.com/Centos-6-Vault-Aliyun.repo4.yum clean all5.yum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>感谢：<a href="https://zhuanlan.zhihu.com/p/338873211">https://zhuanlan.zhihu.com/p/338873211</a>    </p><p>安装Erlang</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">```问题，无法查看glibc版本：改为```shstrings /lib/libc.so.6 | grep GLIBC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更新glibc</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &amp;wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &amp;sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>无效，使用docker部署安装!!!!</strong></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#从网络中查找 rabbitmqdocker search rabbitmq#从Docker仓库下载镜像到本地docker pull  rabbitmqdocker run -id --name=c_rabbitmq \-p 15672:15672 \rabbitmq docker exec <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-RabbitMQ入门程序"><a href="#2-3-RabbitMQ入门程序" class="headerlink" title="2.3 RabbitMQ入门程序"></a>2.3 RabbitMQ入门程序</h4><p>需求：使用简单模式完成消息传递 步骤：</p><ol><li> 创建工程（生成者、消费者） </li><li>分别添加依赖 </li><li>编写生产者发送消息 </li><li>编写消费者接收消息</li></ol><p><img src="/2021/11/18/rabbitmq/image-20211120165146749.png" alt="入门案例"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Java </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper</title>
      <link href="/2021/11/17/zookeeper/"/>
      <url>/2021/11/17/zookeeper/</url>
      
        <content type="html"><![CDATA[<h3 id="初识Zookeeper"><a href="#初识Zookeeper" class="headerlink" title="初识Zookeeper"></a>初识Zookeeper</h3><h5 id="Zookeeper概念"><a href="#Zookeeper概念" class="headerlink" title="Zookeeper概念"></a>Zookeeper概念</h5><ul><li>Zookeeper 是 Apache Hadoop 项目下的一个子项目，是一个树形目录服务。</li><li>Zookeeper 翻译过来就是 动物园管理员，他是用来管 Hadoop（大象）、Hive(蜜蜂)、Pig(小 猪)的管理员。简称zk</li><li>Zookeeper 是一个分布式的、开源的分布式应用程序的协调服务。</li><li>Zookeeper 提供的主要功能包括：<ul><li>配置管理        <img src="/2021/11/17/zookeeper/image-20211117141716564.png" alt="配置中心"></li><li>分布式锁   <img src="/2021/11/17/zookeeper/image-20211117141746714.png"><ul><li>集群管理       <img src="/2021/11/17/zookeeper/image-20211117141815449.png"></li></ul></li></ul></li></ul><h3 id="Zookeeper命令"><a href="#Zookeeper命令" class="headerlink" title="Zookeeper命令"></a>Zookeeper命令</h3><h5 id="zookeeper数据模型"><a href="#zookeeper数据模型" class="headerlink" title="zookeeper数据模型"></a>zookeeper数据模型</h5><ul><li><p>ZooKeeper 是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构。</p></li><li><p>这里面的每一个节点都被称为： ZNode，每个节点上都会保存自己的数据和节点信息。</p></li><li><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下。</p></li><li><p>节点可以分为四大类：</p><p>•PERSISTENT 持久化节点</p><p>•EPHEMERAL 临时节点 ：-e</p><p>•PERSISTENT_SEQUENTIAL 持久化顺序节点 ：-s</p><p>•EPHEMERAL_SEQUENTIAL 临时顺序节点 ：-es</p></li></ul><h5 id="zookeeper服务端常用命令"><a href="#zookeeper服务端常用命令" class="headerlink" title="zookeeper服务端常用命令"></a>zookeeper服务端常用命令</h5><ul><li>启动 ZooKeeper 服务: ./zkServer.sh start</li><li>查看 ZooKeeper 服务状态: ./zkServer.sh status</li><li>停止 ZooKeeper 服务: ./zkServer.sh stop </li><li>重启 ZooKeeper 服务: ./zkServer.sh restart </li></ul><h5 id="zookeeper客户端常用命令"><a href="#zookeeper客户端常用命令" class="headerlink" title="zookeeper客户端常用命令"></a>zookeeper客户端常用命令</h5><ul><li><p>连接ZooKeeper服务端</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">./zkCli.sh –server ip:port<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>断开连接</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">quit<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看命令帮助</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">help<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>显示指定目录下节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ls 目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">create /节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取节点值</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">get /节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置节点值</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">set /节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除单个节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">delete /节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除带有子节点的节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">deleteall /节点path<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建临时节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">create -e /节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建顺序节点</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">create -s /节点path value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询节点详细信息</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ls –s /节点path <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>•czxid：节点被创建的事务ID</p><p>•ctime: 创建时间 </p><p>•mzxid: 最后一次被更新的事务ID </p><p>•mtime: 修改时间 </p><p>•pzxid：子节点列表最后一次被更新的事务ID</p><p>•cversion：子节点的版本号</p><p>•dataversion：数据版本号</p><p>•aclversion：权限版本号</p><p>•ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0</p><p>•dataLength：节点存储的数据的长度</p><p>•numChildren：当前节点的子节点个数</p><p><img src="/2021/11/17/zookeeper/image-20211117144011418.png" alt="节点"></p></li></ul><h4 id="Zookeeper-JavaAPI-操作"><a href="#Zookeeper-JavaAPI-操作" class="headerlink" title="Zookeeper JavaAPI 操作"></a>Zookeeper JavaAPI 操作</h4><h5 id="Curator介绍"><a href="#Curator介绍" class="headerlink" title="Curator介绍"></a>Curator介绍</h5><ul><li>Curator 是 Apache ZooKeeper 的Java客户端库。</li><li>常见的ZooKeeper Java API ：<ul><li>原生Java API</li><li>ZkClient</li><li>Curator</li></ul></li><li>Curator 项目的目标是简化 ZooKeeper 客户端的使用。</li><li>Curator 最初是 Netfix 研发的,后来捐献了 Apache 基金会,目前是 Apache 的顶级项目。</li><li>官网：<a href="http://curator.apache.org/">http://curator.apache.org/</a></li></ul><h5 id="Curator-API-常用操作"><a href="#Curator-API-常用操作" class="headerlink" title="Curator API 常用操作"></a>Curator API 常用操作</h5><ul><li><p>建立连接</p></li><li><p>添加节点</p></li><li><p>删除节点</p></li><li><p>修改节点</p></li><li><p>查询节点</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>itheima<span class="token punctuation">.</span>curator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span></span><span class="token class-name">RetryPolicy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span></span><span class="token class-name">CuratorFramework</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span></span><span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">BackgroundCallback</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">CuratorEvent</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span></span><span class="token class-name">CreateMode</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>zookeeper<span class="token punctuation">.</span>data<span class="token punctuation">.</span></span><span class="token class-name">Stat</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">After</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Before</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CuratorTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">CuratorFramework</span> client<span class="token punctuation">;</span>    <span class="token comment">/**     * 建立连接     */</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">/*         *         * @param connectString       连接字符串。zk server 地址和端口 "192.168.149.135:2181,192.168.149.136:2181"         * @param sessionTimeoutMs    会话超时时间 单位ms         * @param connectionTimeoutMs 连接超时时间 单位ms         * @param retryPolicy         重试策略         */</span>       <span class="token comment">/* //重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000,10);        //1.第一种方式        CuratorFramework client = CuratorFrameworkFactory.newClient("192.168.149.135:2181",                60 * 1000, 15 * 1000, retryPolicy);*/</span>        <span class="token comment">//重试策略</span>        <span class="token class-name">RetryPolicy</span> retryPolicy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.第二种方式</span>        <span class="token comment">//CuratorFrameworkFactory.builder();</span>        client <span class="token operator">=</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">connectString</span><span class="token punctuation">(</span><span class="token string">"192.168.149.135:2181"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">sessionTimeoutMs</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">connectionTimeoutMs</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">retryPolicy</span><span class="token punctuation">(</span>retryPolicy<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">namespace</span><span class="token punctuation">(</span><span class="token string">"itheima"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启连接</span>        client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//==============================create=============================================================================</span>    <span class="token comment">/**     * 创建节点：create 持久 临时 顺序 数据     * 1. 基本创建 ：create().forPath("")     * 2. 创建节点 带有数据:create().forPath("",data)     * 3. 设置节点的类型：create().withMode().forPath("",data)     * 4. 创建多级节点  /app1/p1 ：create().creatingParentsIfNeeded().forPath("",data)     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//2. 创建节点 带有数据</span>        <span class="token comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app2"</span><span class="token punctuation">,</span> <span class="token string">"hehe"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCreate2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//1. 基本创建</span>        <span class="token comment">//如果创建节点，没有指定数据，则默认将当前客户端的ip作为数据存储</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCreate3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//3. 设置节点的类型</span>        <span class="token comment">//默认类型：持久化</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withMode</span><span class="token punctuation">(</span><span class="token class-name">CreateMode</span><span class="token punctuation">.</span>EPHEMERAL<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCreate4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//4. 创建多级节点  /app1/p1</span>        <span class="token comment">//creatingParentsIfNeeded():如果父节点不存在，则创建父节点</span>        <span class="token class-name">String</span> path <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">creatingParentsIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app4/p1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//===========================get================================================================================</span>    <span class="token comment">/**     * 查询节点：     * 1. 查询数据：get: getData().forPath()     * 2. 查询子节点： ls: getChildren().forPath()     * 3. 查询节点状态信息：ls -s:getData().storingStatIn(状态对象).forPath()     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGet1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//1. 查询数据：get</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGet2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 2. 查询子节点： ls</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGet3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Stat</span> status <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 查询节点状态信息：ls -s</span>        client<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">storingStatIn</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">//===========================set================================================================================</span>    <span class="token comment">/**     * 修改数据     * 1. 基本修改数据：setData().forPath()     * 2. 根据版本修改: setData().withVersion().forPath()     * * version 是通过查询出来的。目的就是为了让其他客户端或者线程不干扰我。     *     * @throws Exception     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        client<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">,</span> <span class="token string">"itcast"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSetForVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Stat</span> status <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 查询节点状态信息：ls -s</span>        client<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">storingStatIn</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> version <span class="token operator">=</span> status<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//查询出来的 3</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withVersion</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">,</span> <span class="token string">"hehe"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment">//===========================delete==================================================</span>    <span class="token comment">/**     * 删除节点： delete deleteall     * 1. 删除单个节点:delete().forPath("/app1");     * 2. 删除带有子节点的节点:delete().deletingChildrenIfNeeded().forPath("/app1");     * 3. 必须成功的删除:为了防止网络抖动。本质就是重试。  client.delete().guaranteed().forPath("/app2");     * 4. 回调：inBackground     * @throws Exception     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 1. 删除单个节点</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//2. 删除带有子节点的节点</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">deletingChildrenIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//3. 必须成功的删除</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">guaranteed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDelete4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//4. 回调</span>        client<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">guaranteed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">inBackground</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BackgroundCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processResult</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> client<span class="token punctuation">,</span> <span class="token class-name">CuratorEvent</span> event<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我被删除了~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forPath</span><span class="token punctuation">(</span><span class="token string">"/app1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@After</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>client <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Watch事件监听</p></li></ul><h6 id="Curator-API-常用操作-Watch事件监听"><a href="#Curator-API-常用操作-Watch事件监听" class="headerlink" title="Curator API 常用操作  Watch事件监听"></a><strong>Curator API</strong> <strong>常用操作</strong>  Watch事件监听</h6><ul><li>ZooKeeper 允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</li><li>ZooKeeper 中引入了Watcher机制来实现了发布/订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</li><li>ZooKeeper 原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便</li><li>  需要开发人员自己反复注册Watcher，比较繁琐。</li><li>Curator引入了 Cache 来实现对 ZooKeeper 服务端事件的监听。</li><li>ZooKeeper提供了三种Watcher：<ul><li>NodeCache : 只是监听某一个特定的节点</li><li>PathChildrenCache : 监控一个ZNode的子节点. </li><li>TreeCache : 可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li></ul></li></ul><p><img src="/2021/11/17/zookeeper/image-20211117160938191.png" alt="事件监听"></p><pre class="line-numbers language-jade" data-language="jade"><code class="language-jade">import org.apache.curator.RetryPolicy;import org.apache.curator.framework.CuratorFramework;import org.apache.curator.framework.CuratorFrameworkFactory;import org.apache.curator.framework.api.BackgroundCallback;import org.apache.curator.framework.api.CuratorEvent;import org.apache.curator.framework.recipes.cache.*;import org.apache.curator.retry.ExponentialBackoffRetry;import org.apache.zookeeper.CreateMode;import org.apache.zookeeper.data.Stat;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.util.List;public class CuratorWatcherTest {    private CuratorFramework client;    /**     * 建立连接     */    @Before    public void testConnect() {        /*         *         * @param connectString       连接字符串。zk server 地址和端口 "192.168.149.135:2181,192.168.149.136:2181"         * @param sessionTimeoutMs    会话超时时间 单位ms         * @param connectionTimeoutMs 连接超时时间 单位ms         * @param retryPolicy         重试策略         */       /* //重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000,10);        //1.第一种方式        CuratorFramework client = CuratorFrameworkFactory.newClient("192.168.149.135:2181",                60 * 1000, 15 * 1000, retryPolicy);*/        //重试策略        RetryPolicy retryPolicy = new ExponentialBackoffRetry(3000, 10);        //2.第二种方式        //CuratorFrameworkFactory.builder();        client = CuratorFrameworkFactory.builder()                .connectString("192.168.149.135:2181")                .sessionTimeoutMs(60 * 1000)                .connectionTimeoutMs(15 * 1000)                .retryPolicy(retryPolicy)                .namespace("itheima")                .build();        //开启连接        client.start();    }    @After    public void close() {        if (client != null) {            client.close();        }    }    /**     * 演示 NodeCache：给指定一个节点注册监听器     */    @Test    public void testNodeCache() throws Exception {        //1. 创建NodeCache对象        final NodeCache nodeCache = new NodeCache(client,"/app1");        //2. 注册监听        nodeCache.getListenable().addListener(new NodeCacheListener() {            @Override            public void nodeChanged() throws Exception {                System.out.println("节点变化了~");                //获取修改节点后的数据                byte[] data = nodeCache.getCurrentData().getData();                System.out.println(new String(data));            }        });        //3. 开启监听.如果设置为true，则开启监听是，加载缓冲数据        nodeCache.start(true);        while (true){        }    }    /**     * 演示 PathChildrenCache：监听某个节点的所有子节点们     */    @Test    public void testPathChildrenCache() throws Exception {        //1.创建监听对象        PathChildrenCache pathChildrenCache = new PathChildrenCache(client,"/app2",true);        //2. 绑定监听器        pathChildrenCache.getListenable().addListener(new PathChildrenCacheListener() {            @Override            public void childEvent(CuratorFramework client, PathChildrenCacheEvent event) throws Exception {                System.out.println("子节点变化了~");                System.out.println(event);                //监听子节点的数据变更，并且拿到变更后的数据                //1.获取类型                PathChildrenCacheEvent.Type type = event.getType();                //2.判断类型是否是update                if(type.equals(PathChildrenCacheEvent.Type.CHILD_UPDATED)){                    System.out.println("数据变了！！！");                    byte[] data = event.getData().getData();                    System.out.println(new String(data));                }            }        });        //3. 开启        pathChildrenCache.start();        while (true){        }    }    /**     * 演示 TreeCache：监听某个节点自己和所有子节点们     */    @Test    public void testTreeCache() throws Exception {        //1. 创建监听器        TreeCache treeCache = new TreeCache(client,"/app2");        //2. 注册监听        treeCache.getListenable().addListener(new TreeCacheListener() {            @Override            public void childEvent(CuratorFramework client, TreeCacheEvent event) throws Exception {                System.out.println("节点变化了");                System.out.println(event);            }        });        //3. 开启        treeCache.start();        while (true){        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>分布式锁实现</li></ul><h6 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h6><ul><li>在我们进行单机应用开发，涉及并发同步的时候，我们往往采用synchronized或者Lock的方式来解决多线程间的代码同步问题，这时多线程的运行都是在同一个JVM之下，没有任何问题。</li><li>但当我们的应用是分布式集群工作的情况下，属于多JVM下的工作环境，跨JVM之间已经无法通过多线程的锁解决同步问题。</li><li>那么就需要一种更加高级的锁机制，来处理种<strong>跨机器的进程之间的数据同步问题</strong>——这就是分布式锁。</li></ul><p><img src="/2021/11/17/zookeeper/image-20211117163212283.png" alt="分布式锁"></p><h6 id="Zookeeper分布式锁原理"><a href="#Zookeeper分布式锁原理" class="headerlink" title="Zookeeper分布式锁原理"></a>Zookeeper分布式锁原理</h6><p><strong>核心思想</strong>：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li><p>客户端获取锁时，在lock节点下创建<strong>临时顺序</strong>节点。</p></li><li><p>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</p></li><li><p>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。</p></li><li><p>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁， 如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。<img src="/2021/11/17/zookeeper/image-20211117163414876.png" alt="分布式锁的实现"></p></li></ol><h6 id="Curator分布式锁实现"><a href="#Curator分布式锁实现" class="headerlink" title="Curator分布式锁实现"></a>Curator分布式锁实现</h6><p><strong>在Curator中有五种锁方案：</strong></p><ul><li>InterProcessSemaphoreMutex：分布式排它锁（非可重入锁）</li><li>InterProcessMutex：分布式可重入排它锁</li><li>InterProcessReadWriteLock：分布式读写锁</li><li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li><li>InterProcessSemaphoreV2：共享信号量</li></ul><p><strong>12306买票案例</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span></span><span class="token class-name">RetryPolicy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span></span><span class="token class-name">CuratorFramework</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span></span><span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>recipes<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">InterProcessMutex</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>curator<span class="token punctuation">.</span>retry<span class="token punctuation">.</span></span><span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Ticket12306</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> tickets <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token comment">//数据库的票数</span>    <span class="token keyword">private</span> <span class="token class-name">InterProcessMutex</span> lock <span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Ticket12306</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//重试策略</span>        <span class="token class-name">RetryPolicy</span> retryPolicy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ExponentialBackoffRetry</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.第二种方式</span>        <span class="token comment">//CuratorFrameworkFactory.builder();</span>        <span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">CuratorFrameworkFactory</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">connectString</span><span class="token punctuation">(</span><span class="token string">"192.168.149.135:2181"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">sessionTimeoutMs</span><span class="token punctuation">(</span><span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">connectionTimeoutMs</span><span class="token punctuation">(</span><span class="token number">15</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">retryPolicy</span><span class="token punctuation">(</span>retryPolicy<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//开启连接</span>        client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span><span class="token string">"/lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//获取锁</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>tickets <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>tickets<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    tickets<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment">//释放锁</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//d</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Ticket12306</span> ticket12306 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Ticket12306</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建客户端</span>        <span class="token class-name">Thread</span> t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ticket12306<span class="token punctuation">,</span><span class="token string">"携程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>ticket12306<span class="token punctuation">,</span><span class="token string">"飞猪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/11/17/zookeeper/image-20211117145521182.png" alt="image-20211117145521182"></p><h4 id="Zookeeper集群搭建"><a href="#Zookeeper集群搭建" class="headerlink" title="Zookeeper集群搭建"></a>Zookeeper集群搭建</h4><h5 id="Zookeeper集群介绍"><a href="#Zookeeper集群介绍" class="headerlink" title="Zookeeper集群介绍"></a>Zookeeper集群介绍</h5><p><strong>Leader选举：</strong></p><ul><li><p>Serverid：服务器ID</p><p> 比如有三台服务器，编号分别是1,2,3。</p><p> 编号越大在选择算法中的权重越大。</p></li><li><p>Zxid：数据ID</p><p> 服务器中存放的最大数据ID.值越大说明数据 越新，在选举算法中数据越新权重越大。</p></li><li><p>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票， 则此ZooKeeper就可以成为Leader了。</p></li></ul><p><img src="/2021/11/17/zookeeper/image-20211117165916731.png" alt="Zookeeper集群"></p><h5 id="Zookeeper集群角色"><a href="#Zookeeper集群角色" class="headerlink" title="Zookeeper集群角色"></a>Zookeeper集群角色</h5><p>在ZooKeeper集群服中务中有三个角色：</p><ul><li><p>•Leader 领导者 ：     </p><p>处理事务请求</p></li></ul><p>​        集群内部各服务器的调度者</p><ul><li><p>•Follower 跟随者 ：</p><p>​    处理客户端非事务请求，转发事务请求给Leader服务器</p><p>​    参与Leader选举投票</p></li><li><p>•Observer 观察者：</p><ol><li> 处理客户端非事务请求，转发事务请求给Leader服务器</li></ol></li></ul><p><img src="/2021/11/17/zookeeper/image-20211117170105218.png" alt="集群角色"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Java </tag>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法--数据结构</title>
      <link href="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/"/>
      <url>/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构分类</p><p><strong>逻辑结构分类：</strong></p><ul><li><p>集合结构：数据元素除了同属于一个集合外，没有其他关系。</p></li><li><p>线性结构： 数据元素之间存在着一对一关系</p></li><li><p>树形结构： 数据元素之间存在着一对多的关系</p></li><li><p>图形结构：数据元素是多对多的关系</p></li></ul><p><strong>物理结构分类：</strong>逻辑结构在计算机中的真正表现形式</p><ul><li>顺序存储结构：把元素放在连续的存储单元里，其数据间的逻辑关系和物理关系是一致的</li><li>链式存储结构：把数据元素存放在任意的存储单元里，可以是连续的也可以是不连续的，，通过指针映射地址。</li></ul><h3 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h3><p>​    线性表是最基本。最简单。也是最常用的一种数据结构。</p><p>​    一个线性表是n个具有相同特征的数据元素的有限序列。</p><ul><li><p>前驱元素：</p><p>若A元素在B元素的前面，则称A为B的前驱元素</p></li><li><p>后继元素</p><p>若A元素在B元素的后面，则称A为B的后继元素</p></li></ul><p><strong>线性表的特征：</strong>数据之间具有一种”一对一“的逻辑关系</p><ol><li>第一个数据元素没有前驱元素，这个数据元素被称为头节点</li><li>第一个数据元素没有后继元素，这个数据元素被称为尾节点</li><li>除了第一个和最后一个元素除外，其他数据都有且仅有一个前驱元素和后继元素</li></ol><p>ai-1是ai的前驱元素，ai+1是ai的后继元素。</p><p><strong>线性表的分类</strong></p><ul><li>顺序存储：顺序表</li><li>链式存储：链表</li></ul><h4 id="1-1顺序表"><a href="#1-1顺序表" class="headerlink" title="1.1顺序表"></a>1.1顺序表</h4><p>​    顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表的各个元素。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211116191826671.png" alt="数组"></p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SequenceList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储元素的数组</span>    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> eles<span class="token punctuation">;</span>    <span class="token comment">//记录当前顺序表中的元素个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token comment">//构造方法</span>    <span class="token keyword">public</span> <span class="token class-name">SequenceList</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//初始化数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>eles <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化长度</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//将一个线性表置为空表</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断当前线性表是否为空表</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取线性表的长度</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取指定位置的元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> eles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向线性表中添加元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        eles<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//在i索引处添加元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//i之后的元素后移</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token class-name">N</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> index<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            eles<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> eles<span class="token punctuation">[</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//i处放入t</span>        eles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除并返回线性表中第i个数据元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> t <span class="token operator">=</span> eles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span> index <span class="token operator">&lt;</span> eles<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            eles<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> eles<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//查找t元素第一次出现的位置</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>顺序表的遍历：</p><ul><li>实现lterable接口，重写iterator接口</li><li>在SequenceList内部提供一个内部类；实现iterator接口，重写hasNext方法和next方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>   <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token punctuation">{</span>       <span class="token keyword">private</span> <span class="token keyword">int</span> cusor<span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token class-name">SIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>cusor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> cusor<span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> eles<span class="token punctuation">[</span>cusor<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2链表"><a href="#1-2链表" class="headerlink" title="1.2链表"></a>1.2链表</h4><p>链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元 素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成， 结点可以在运行时动态生成。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117090858816.png" alt="链表"></p><p>节点实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> item<span class="token punctuation">;</span>    <span class="token comment">//指向下一个结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成链表：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span><span class="token comment">//构建结点</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> third <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> fourth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> fifth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//生成链表</span>    first<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">;</span>    second<span class="token punctuation">.</span>next <span class="token operator">=</span> third<span class="token punctuation">;</span>    third<span class="token punctuation">.</span>next <span class="token operator">=</span> fourth<span class="token punctuation">;</span>    fourth<span class="token punctuation">.</span>next <span class="token operator">=</span> fifth<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码实现:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LinkList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//记录头结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">//记录链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始化头结点</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//清空链表</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取链表的长度</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断链表是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取指定位置i出的元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//向链表中添加元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//找到最后一个节点</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        n<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment">//链表长度+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向指定位置i处，添加元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//寻找位置i之前的结点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//位置i的结点</span>        <span class="token class-name">Node</span> curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">//构建新的结点，让新结点指向位置i的结点</span>        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//让之前的结点指向新结点</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        <span class="token comment">//长度+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment">//删除指定位置i处的元素，并返回被删除的元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//寻找i之前的元素</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//当前i位置的结点</span>        <span class="token class-name">Node</span> curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">//前一个结点指向下一个结点，删除当前结点</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">//长度-1</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> curr<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//查找元素t在链表中第一次出现的位置</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>item<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//结点类</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token comment">//存储数据</span>        <span class="token class-name">T</span> item<span class="token punctuation">;</span>        <span class="token comment">//下一个结点</span>        <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">LIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span> n<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-1单向链表"><a href="#1-2-1单向链表" class="headerlink" title="1.2.1单向链表"></a>1.2.1单向链表</h5><p>​    单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据， 指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117091657340.png" alt="单向链表"></p><h5 id="1-2-2-双向链表"><a href="#1-2-2-双向链表" class="headerlink" title="1.2.2 双向链表"></a>1.2.2 双向链表</h5><p>​    双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存 储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117091815476.png" alt="双向链表"></p><p>双向链表的节点：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> item<span class="token punctuation">;</span>    <span class="token comment">//指向下一个结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token comment">//指向上一个节点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> pre<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span><span class="token class-name">Node</span> pre<span class="token punctuation">,</span><span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pre<span class="token operator">=</span>pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码设计：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TowWayLinkList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//首结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">//最后一个结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> last<span class="token punctuation">;</span>    <span class="token comment">//链表的长度</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">TowWayLinkList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//清空链表</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取链表长度</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断链表是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//插入元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> head<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span> oldLast <span class="token operator">=</span> last<span class="token punctuation">;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> oldLast<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oldLast<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            last <span class="token operator">=</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//长度+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向指定位置i处插入元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//找到位置i的前一个结点</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//当前结点</span>        <span class="token class-name">Node</span> curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//构建新结点</span>        <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> pre<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>        curr<span class="token punctuation">.</span>pre <span class="token operator">=</span> newNode<span class="token punctuation">;</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token comment">//长度+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取指定位置i处的元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//寻找当前结点</span>        <span class="token class-name">Node</span> curr <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> curr<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//找到元素t在链表中第一次出现的位置</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除位置i处的元素，并返回该元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">&gt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"位置不合法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//寻找i位置的前一个元素</span>        <span class="token class-name">Node</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//i位置的元素</span>        <span class="token class-name">Node</span> curr <span class="token operator">=</span> pre<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//i位置的下一个元素</span>        <span class="token class-name">Node</span> curr_next <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        pre<span class="token punctuation">.</span>next <span class="token operator">=</span> curr_next<span class="token punctuation">;</span>        curr_next<span class="token punctuation">.</span>pre <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token comment">//长度-1；</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> curr<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取第一个元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">//获取最后一个元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> last<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">TIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-3循环链表"><a href="#1-2-3循环链表" class="headerlink" title="1.2.3循环链表"></a>1.2.3循环链表</h5><p>​    循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结 点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117112046445.png" alt="循环链表"></p><h4 id="1-3栈和队列"><a href="#1-3栈和队列" class="headerlink" title="1.3栈和队列"></a>1.3栈和队列</h4><h5 id="1-3-1栈"><a href="#1-3-1栈" class="headerlink" title="1.3.1栈"></a>1.3.1栈</h5><p>​    栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一 个数据被第一个读出来）。</p><p>​    我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117193244899.png" alt="栈"></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//栈代码</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//记录首结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">//栈中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断当前栈中元素个数是否为0</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//把t元素压入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> oldNext <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> oldNext<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token comment">//个数+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//弹出栈顶元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> oldNext <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldNext <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//删除首个元素</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token comment">//个数-1</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> oldNext<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取栈中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">SIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> item<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3-2-队列"><a href="#1-3-2-队列" class="headerlink" title="1.3.2 队列"></a>1.3.2 队列</h5><p>​    队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它 按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211117202437964.png" alt="队列"></p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//队列代码</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//记录首结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">//记录最后一个结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> last<span class="token punctuation">;</span>    <span class="token comment">//记录队列中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回队列中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向队列中插入元素t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span> oldLast <span class="token operator">=</span> last<span class="token punctuation">;</span>            last <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            oldLast<span class="token punctuation">.</span>next <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//个数+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//从队列中拿出一个元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">Node</span> oldFirst <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> oldFirst<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> oldFirst<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">QIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">QIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> n<span class="token punctuation">.</span>next <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>item<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token class-name">T</span> item<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-符号表"><a href="#2-符号表" class="headerlink" title="2.符号表"></a>2.符号表</h3><h4 id="2-1符号表"><a href="#2-1符号表" class="headerlink" title="2.1符号表"></a>2.1符号表</h4><p>​    符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的 键值对数据，我们可以根据键来查找对应的值。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118094026343.png" alt="符号表存储学生"></p><p><strong>符号表中，键具有唯一性。</strong></p><p>应用：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118094150612.png" alt="image-20211118094150612"></p><p><strong>符号表使用链表实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>map</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SymbolTable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span><span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//记录首结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token comment">//记录符号表中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">SymbolTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">N</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取符号表中键值对的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//往符号表中插入键值对</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span><span class="token class-name">Value</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//先从符号表中查找键为key的键值对</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                n<span class="token punctuation">.</span>value<span class="token operator">=</span>value<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token comment">//符号表中没有键为key的键值对</span>        <span class="token class-name">Node</span> oldFirst <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token class-name">Node</span> newFirst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">,</span>oldFirst<span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> newFirst<span class="token punctuation">;</span>        <span class="token comment">//个数+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除符号表中键为key的键值对</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>next<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                n<span class="token punctuation">.</span>next <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//从符号表中获取key对应的值</span>    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Node</span> n <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> n<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>        <span class="token comment">//键</span>        <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>        <span class="token comment">//值</span>        <span class="token keyword">public</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>        <span class="token comment">//下一个结点</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-1-2-有序符号表"><a href="#2-1-2-有序符号表" class="headerlink" title="2.1.2 有序符号表"></a>2.1.2 有序符号表</h5><p>​        刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活 中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，</p><p>通过修改符号表的put方法实现有序符号表：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//往符号表中插入键值对</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span><span class="token class-name">Value</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//记录当前结点</span>    <span class="token class-name">Node</span> curr <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">//记录上一个结点</span>    <span class="token class-name">Node</span> pre <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token comment">//1.如果key大于当前结点的key，则一直寻找下一个结点</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        pre <span class="token operator">=</span> curr<span class="token punctuation">;</span>        curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2.如果当前结点curr的key和将要插入的key一样，则替换</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> curr<span class="token punctuation">.</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        curr<span class="token punctuation">.</span>value<span class="token operator">=</span>value<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//3.没有找到相同的key，把新结点插入到curr之前</span>    <span class="token class-name">Node</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> curr<span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h3><h5 id="3-1-1-树简介"><a href="#3-1-1-树简介" class="headerlink" title="3.1.1 树简介"></a>3.1.1 树简介</h5><p>​    树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家 谱、单位的组织架构、等等。 </p><p>​    树是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就 是说它是根朝上，而叶朝下的。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118102517538.png" alt="树的结构"></p><p>树具有以下特点：</p><ol><li><p>每个结点有零个或多个子结点； </p></li><li><p>没有父结点的结点为根结点； </p></li><li><p>每一个非根结点只有一个父结点；</p></li><li><p>每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；</p></li></ol><h5 id="3-1-2树的相关术语："><a href="#3-1-2树的相关术语：" class="headerlink" title="3.1.2树的相关术语："></a>3.1.2树的相关术语：</h5><ul><li>结点的度：<br>一个结点含有的子树的个数称为该结点的度；</li><li>叶节点<br>度为0的结点称为叶结点，也可以叫做终端结点</li><li>分支结点：<br>度不为0的结点称为分支结点，也可以叫做非终端结点</li><li>结点的层次：<br>从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推</li><li>结点的层序编号：<br>将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。</li><li>树的度：<br>树中所有结点的度的最大值</li><li>树的高度(深度)：<br>树中结点的最大层次</li><li>森林：<br>m（m&gt;=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根 结点，森林就变成一棵树<ul><li><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118103052542-16372026631961.png" alt="森林"></li></ul></li><li>孩子结点：<br>一个结点的直接后继结点称为该结点的孩子结点</li><li>双亲结点(父结点)：<br>一个结点的直接前驱称为该结点的双亲结点</li><li>兄弟结点：<br>同一双亲结点的孩子结点间互称兄弟结点</li></ul><h4 id="3-2二叉树"><a href="#3-2二叉树" class="headerlink" title="3.2二叉树"></a>3.2二叉树</h4><h5 id="3-2-1二叉树的基本定义"><a href="#3-2-1二叉树的基本定义" class="headerlink" title="3.2.1二叉树的基本定义"></a>3.2.1二叉树的基本定义</h5><p>​    二叉树就是度不超过二的树（每个结点最多有两个子结点）</p><p><strong>满二叉树：</strong></p><p>​    一个二叉树，如果每一层的结点数都达到最大值，则这个二叉树就是满二叉树。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118103952771.png" alt="满二叉树"></p><p><strong>完全二叉树：</strong></p><p>​    叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层的最左边的若干位置的二叉树</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118104154531.png" alt="完全二叉树"></p><h5 id="3-2-2二叉查找树的创建"><a href="#3-2-2二叉查找树的创建" class="headerlink" title="3.2.2二叉查找树的创建"></a>3.2.2二叉查找树的创建</h5><p>节点类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span><span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token comment">//存储键</span>    <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>    <span class="token comment">//存储值</span>    <span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>    <span class="token comment">//记录左子结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>    <span class="token comment">//记录右子结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>二叉查找树put方法思想：</strong></p><ol><li><p>如果当前树中没有任何一个结点，则直接把新结点当做根结点使用</p></li><li><p>如果当前树不为空，则从根结点开始：</p><ol><li> 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；</li><li> 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；</li><li> 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。</li></ol></li></ol><p><strong>查询方法get实现思想：</strong></p><p> 从根节点开始：</p><ol><li><p>如果要查询的key小于当前结点的key，则继续找当前结点的左子结点； </p></li><li><p>如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</p></li><li><p>如果要查询的key等于当前结点的key，则树中返回当前结点的value。</p></li></ol><p><strong>删除方法delete实现思想：</strong> </p><ol><li><p>找到被删除结点；</p></li><li><p>找到被删除结点右子树中的最小结点minNode </p></li><li><p>删除右子树中的最小结点</p><p><strong>优化：</strong>1.判断最小节点是否有右子树，</p><p>​            有右子树，让右子树成为最小节点的父节点的左子树</p><p>​            无右子树，最小节点的父节点的左子树为null</p></li><li><p>让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树 </p></li><li><p>让被删除结点的父节点指向最小结点minNode</p></li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//二叉树代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BinaryTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//记录根结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>    <span class="token comment">//记录树中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token comment">//获取树中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向树中添加元素key-value</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向指定的树x中添加key-value,并返回添加元素后新的树</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//个数+1</span>            <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//新结点的key大于当前结点的key，继续找当前结点的右子结点</span>            x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//新结点的key小于当前结点的key，继续找当前结点的左子结点</span>            x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//新结点的key等于当前结点的key，把当前结点的value进行替换</span>            x<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//查询树中指定key对应的value</span>    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//从指定的树x中，查找key对应的值</span>    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</span>            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</span>            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//如果要查询的key等于当前结点的key，则树中返回当前结点的value。</span>            <span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除树中key对应的value</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        root <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除指定树x中的key对应的value，并返回删除后的新树</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//新结点的key大于当前结点的key，继续找当前结点的右子结点</span>            x<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//新结点的key小于当前结点的key，继续找当前结点的左子结点</span>            x<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">delete</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//新结点的key等于当前结点的key,当前x就是要删除的结点</span>            <span class="token comment">//1.如果当前结点的右子树不存在，则直接返回当前结点的左子结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//2.如果当前结点的左子树不存在，则直接返回当前结点的右子结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//3.当前结点的左右子树都存在</span>            <span class="token comment">//3.1找到右子树中最小的结点</span>            <span class="token class-name">Node</span> minNode <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>minNode<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minNode <span class="token operator">=</span> minNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//3.2删除右子树中最小的结点</span>            <span class="token class-name">Node</span> n <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//优化</span>                    <span class="token comment">//判断最小节点是否有右子树</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>minNode<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token comment">//有右子树，让右子树成为最小节点的父节点的左子树</span>                        n<span class="token punctuation">.</span>left<span class="token operator">=</span>minNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">//无右子树，删除最小节点</span>                        n<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    n <span class="token operator">=</span> n<span class="token punctuation">.</span>left<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//3.3让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子树</span>            minNode<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            minNode<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token comment">//3.4让被删除结点的父节点指向最小结点minNode</span>            x <span class="token operator">=</span> minNode<span class="token punctuation">;</span>            <span class="token comment">//个数-1</span>            <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token comment">//存储键</span>        <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>        <span class="token comment">//存储值</span>        <span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>        <span class="token comment">//记录左子结点</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>        <span class="token comment">//记录右子结点</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-3查找二叉树中最小和最大的键"><a href="#3-2-3查找二叉树中最小和最大的键" class="headerlink" title="3.2.3查找二叉树中最小和最大的键"></a>3.2.3查找二叉树中最小和最大的键</h5><p>查找最小的键：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//找出整个树中最小的键</span>    <span class="token keyword">public</span> <span class="token class-name">Key</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//找出指定树x中最小的键所在的结点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查找最大的键：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//找出整个树中最大的键</span><span class="token keyword">public</span> <span class="token class-name">Key</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//找出指定树x中最大键所在的结点</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-4二叉树的基础遍历（深度优先）"><a href="#3-2-4二叉树的基础遍历（深度优先）" class="headerlink" title="3.2.4二叉树的基础遍历（深度优先）"></a>3.2.4二叉树的基础遍历（深度优先）</h5><p>​        很多情况下，我们可能需要像遍历数组数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性 结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的搜索路径进行遍历的问 题。</p><p>​         我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访 问，我们可以把二叉树的遍历分为以下三种方式：</p><ol><li><p>前序遍历； 先访问根结点，然后再访问左子树，最后访问右子树 </p></li><li><p>中序遍历； 先访问左子树，中间访问根节点，最后访问右子树 </p></li><li><p>后序遍历； 先访问左子树，再访问右子树，最后访问根节点 </p></li></ol><p>​    如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118133537217.png" alt="遍历二叉树"></p><h6 id="3-2-4-1前序遍历"><a href="#3-2-4-1前序遍历" class="headerlink" title="3.2.4.1前序遍历"></a>3.2.4.1前序遍历</h6><p>​    实现过程中，我们通过前序遍历，把,把每个结点的键取出，放入到队列中返回即可。 </p><p><strong>实现步骤：</strong></p><ol><li><p>把当前结点的key放入到队列中; </p></li><li><p>找到当前结点的左子树，如果不为空，递归遍历左子树 </p></li><li><p>找到当前结点的右子树，如果不为空，递归遍历右子树</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">//使用前序遍历，获取整个树中的所有键</span>  <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">preErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">preErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> keys<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//使用前序遍历，把指定树x中的所有键放入到keys队列中</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment">//1.把当前结点的key放入到队列中;</span>      keys<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//2.找到当前结点的左子树，如果不为空，递归遍历左子树</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">preErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">preErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-2-4-2-中序遍历"><a href="#3-2-4-2-中序遍历" class="headerlink" title="3.2.4.2 中序遍历"></a>3.2.4.2 中序遍历</h6><p><strong>实现步骤：</strong> </p><ol><li><p>找到当前结点的左子树，如果不为空，递归遍历左子树 </p></li><li><p>把当前结点的key放入到队列中; </p></li><li><p>找到当前结点的右子树，如果不为空，递归遍历右子</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">  <span class="token comment">//使用中序遍历，获取整个树中的所有键</span>  <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">midErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">midErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> keys<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">//使用中序遍历，把指定树x中的所有键放入到keys队列中</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">midErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">midErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token comment">//2.把当前结点的key放入到队列中;</span>      keys<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3.找到当前结点的右子树，如果不为空，递归遍历右子树</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">midErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="3-2-4-3-后序遍历"><a href="#3-2-4-3-后序遍历" class="headerlink" title="3.2.4.3 后序遍历"></a>3.2.4.3 后序遍历</h6><p><strong>实现步骤：</strong></p><ol><li><p>找到当前结点的左子树，如果不为空，递归遍历左子树 </p></li><li><p>找到当前结点的右子树，如果不为空，递归遍历右子树</p></li><li><p>把当前结点的key放入到队列中</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//使用后序遍历，获取整个树中的所有键</span>   <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">afterErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">afterErgodic</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> keys<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">//使用后序遍历，把指定树x中的所有键放入到keys队列中</span>   <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">afterErgodic</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//1.找到当前结点的左子树，如果不为空，递归遍历左子树</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token function">afterErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//2.找到当前结点的右子树，如果不为空，递归遍历右子树</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token function">afterErgodic</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//3.把当前结点的key放入到队列中;</span>       keys<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-5二叉树的层序遍历-广度优先"><a href="#3-2-5二叉树的层序遍历-广度优先" class="headerlink" title="3.2.5二叉树的层序遍历(广度优先)"></a>3.2.5二叉树的层序遍历(广度优先)</h5><p>​    所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值，有二叉树如下：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118140124139.png" alt="层序遍历"></p><p>​    那么层序遍历的结果是：EBGADFHC</p><p><strong>实现步骤：</strong> </p><ol><li><p>创建队列，存储每一层的结点；</p></li><li><p>使用循环从队列中弹出一个结点：</p><p>​     2.1 获取当前结点的key；</p><p>​     2.2 如果当前结点的左子结点不为空，则把左子结点放入到队列中    </p><p>​     2.3 如果当前结点的右子结点不为空，则把右子结点放入到队列中</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211118140230111.png" alt="层序遍历实现"></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//使用层序遍历得到树中所有的键</span>   <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> <span class="token function">layerErgodic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> nodes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       nodes<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>nodes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token class-name">Node</span> x <span class="token operator">=</span> nodes<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           keys<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               nodes<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               nodes<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token keyword">return</span> keys<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h3><h5 id="4-1-堆的定义："><a href="#4-1-堆的定义：" class="headerlink" title="4.1 堆的定义："></a>4.1 堆的定义：</h5><p>​    堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。</p><p><strong>堆的特性：</strong></p><ol><li><p>它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119091908177.png" alt="二叉树"></p></li><li><p>它通常用数组来实现。 具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子 结点则分别在位置4,5,6和7，以此类推。</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119091944589.png" alt="堆排列"></p><p>​            如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不 使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2,向下一层就 令k等于2k或2k+1。</p><ol start="3"><li>每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个 子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的。</li></ol><h5 id="4-2堆的实现"><a href="#4-2堆的实现" class="headerlink" title="4.2堆的实现"></a>4.2堆的实现</h5><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119093712452.png" alt="堆的API"></p><h6 id="4-2-1-insert插入方法的实现"><a href="#4-2-1-insert插入方法的实现" class="headerlink" title="4.2.1 insert插入方法的实现"></a>4.2.1 insert插入方法的实现</h6><p>​    堆是用数组完成数据元素的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只 能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等 于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些 方法让刚才插入的这个数据放入到合适的位置。</p><p> <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119093928405.png" alt="堆插入"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119093954020.png" alt="堆插入（2）"></p><p>​    所以，如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成 数据元素的交换，就可以完成堆的有序调整。只要大于父节点就交换</p><h6 id="4-2-2delMax删除最大元素方法的实现"><a href="#4-2-2delMax删除最大元素方法的实现" class="headerlink" title="4.2.2delMax删除最大元素方法的实现"></a>4.2.2delMax删除最大元素方法的实现</h6><p>​    由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要 有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足 堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置。</p><p>​    所以，当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k] 和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。</p><p><strong>代码实现</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//堆代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Heap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储堆中的元素</span>    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">//记录堆中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Heap</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断堆中索引i处的元素是否小于索引j处的元素</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//交换堆中i索引和j索引处的值</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//往堆中插入一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">[</span><span class="token operator">++</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除堆中最大的元素,并返回这个最大元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> max <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//交换索引1处和索引N处的值</span>        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//删除最后位置上的元素</span>        items<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//个数-1</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果已经到了根结点，就不需要循环了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//比较当前结点和其父结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//父结点小于当前结点，需要交换</span>                <span class="token function">exch</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果当前已经是最底层了，就不需要循环了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//找到子结点中的较大者</span>            <span class="token keyword">int</span> max<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//存在右子结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//不存在右子结点</span>                max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//当前结点小，则交换，</span>            <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-3堆排序"><a href="#4-3堆排序" class="headerlink" title="4.3堆排序"></a>4.3堆排序</h5><p>给定一个数组：</p><p> String[] arr = {“S”,”O”,”R”,”T”,”E”,”X”,”A”,”M”,”P”,”L”,”E”}</p><p> 请对数组中的字符按从小到大排序。</p><p>实现步骤：</p><ol><li><p>构造堆；</p></li><li><p>得到堆顶元素，这个值就是最大值；</p></li><li><p>交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置； </p></li><li><p>对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；</p></li><li><p>重复2~4这个步骤，直到堆中剩一个元素为止。</p></li></ol><p><strong>堆构造过程</strong> </p><p>​    堆的构造，最直观的想法就是另外再创建一个和新数组数组，然后从左往右遍历原数组，每得到一个元素后，添加 到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。 </p><p>​    上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组 0<del>length-1的数据拷贝到新数组的1</del>length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后 对扫描到的每一个元素做下沉调整即可。</p><p><strong>堆排序过程</strong>：</p><p>对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。 </p><ol><li><p>将堆顶元素和堆中最后一个元素交换位置； </p></li><li><p>通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到 了数组的最右边) </p></li><li><p>重复1~2步骤，直到堆中剩最后一个元素。</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//堆排序代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token punctuation">{</span>    <span class="token comment">//对source数组中的数据从小到大排序</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建一个比原数组大1的数组</span>        <span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>source<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//2.构造堆</span>        <span class="token function">createHeap</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> heap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.堆排序</span>        <span class="token comment">//3.1定义一个变量，记录heap中未排序的所有元素中最大的索引</span>        <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> heap<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">N</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//3.2交换heap中索引1处的元素和N处的元素</span>            <span class="token function">exch</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment">//3.3对索引1处的元素在0~N范围内做下沉操作</span>            <span class="token function">sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//4.heap中的数据已经有序，拷贝到source中</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> source<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> source<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//根据原数组source，构造出堆heap</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createHeap</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> source<span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.把source中的数据拷贝到heap中，从heap的1索引处开始填充</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heap<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> source<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.从heap索引的一半处开始倒叙遍历，对得到的每一个元素做下沉操作</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>heap<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">sink</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> heap<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断heap堆中索引i处的元素是否小于索引j处的元素</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//交换heap堆中i索引和j索引处的值</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Comparable</span> tmp <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        heap<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//在heap堆中，对target处的元素做下沉，范围是0~range</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> range<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//没有子结点了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> target <span class="token operator">&lt;=</span> range<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.找出target结点的两个子结点中的较大值</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> target<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> target <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> range<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//存在右子结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> target<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token comment">//2.如果当前结点的值小于子结点中的较大值，则交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> target<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exch</span><span class="token punctuation">(</span>heap<span class="token punctuation">,</span> target<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token comment">//3.更新target的值</span>            target <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-优先队列"><a href="#5-优先队列" class="headerlink" title="5.优先队列"></a>5.优先队列</h3><p>​    普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出 队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我 们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的 队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就 可以使用一种特殊的队列来完成这种需求，优先队列。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119170759887.png" alt="计算机任务队列"></p><p>优先队列按照其作用不同，可以分为以下两种：</p><p> 最大优先队列：<br>    可以获取并删除队列中最大的值</p><p> 最小优先队列：</p><p>​     可以获取并删除队列中最小的值</p><h5 id="5-1最大优先队列"><a href="#5-1最大优先队列" class="headerlink" title="5.1最大优先队列"></a>5.1最大优先队列</h5><p>​    堆这种结构是可以方便的删除最大的值，所以，接下来我们可以基于堆区实现最大优先队 列。</p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>heap</span><span class="token punctuation">;</span><span class="token comment">//最大优先队列代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MaxPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储堆中的元素</span>    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">//记录堆中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MaxPriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>capacity<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取队列中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断堆中索引i处的元素是否小于索引j处的元素</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//交换堆中i索引和j索引处的值</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//往堆中插入一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">[</span><span class="token operator">++</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除堆中最大的元素,并返回这个最大元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">delMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> max <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//交换索引1处和索引N处的值</span>        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除最后位置上的元素</span>        items<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//个数-1</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果已经到了根结点，就不需要循环了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//比较当前结点和其父结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//父结点小于当前结点，需要交换</span>                <span class="token function">exch</span><span class="token punctuation">(</span>k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果当前已经是最底层了，就不需要循环了</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//找到子结点中的较大者</span>            <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//存在右子结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    max <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token comment">//比较当前结点和子结点中的较大者，如果当前结点不小，则结束循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment">//当前结点小，则交换，</span>            <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> max<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-2最小优先队列"><a href="#5-2最小优先队列" class="headerlink" title="5.2最小优先队列"></a>5.2最小优先队列</h5><p>最小优先队列实现起来也比较简单，我们同样也可以基于堆来完成最小优先队列。</p><p> 我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性：</p><ol><li><p><strong>最大的元素放在数组的索引1处。</strong> </p></li><li><p><strong>每个结点的数据总是大于等于它的两个子结点的数据。</strong></p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119171035527.png" alt="最大优先队列"></p><p>其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足 如下特性：</p><ol><li><p><strong>最小的元素放在数组的索引1处。</strong> </p></li><li><p><strong>每个结点的数据总是小于等于它的两个子结点的数据。</strong></p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211119171109237.png" alt="最小优先队列"></p><p>这样我们就能快速的访问到堆中最小的数据。</p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>heap</span><span class="token punctuation">;</span><span class="token comment">//最小优先队列代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储堆中的元素</span>    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">//记录堆中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">MinPriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取队列中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断堆中索引i处的元素是否小于索引j处的元素</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//交换堆中i索引和j索引处的值</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">T</span> tmp <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        items<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//往堆中插入一个元素</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items<span class="token punctuation">[</span><span class="token operator">++</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token function">swim</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除堆中最小的元素,并返回这个最小元素</span>    <span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//索引1处的值是最小值</span>        <span class="token class-name">T</span> min <span class="token operator">=</span> items<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//交换索引1处和索引N处的值</span>        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//删除索引N处的值</span>        items<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">//数据元素-1</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token comment">//对索引1处的值做下沉，使堆重新有序</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//返回被删除的值</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果没有父结点，则不再上浮</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果当前结点比父结点小，则交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果没有子结点，则不再下沉</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//找出子结点中的较小值的索引</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token class-name">N</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment">//如果当前结点小于子结点中的较小值，则结束循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment">//当前结点大，交换</span>            <span class="token function">exch</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-3-索引优先队列"><a href="#5-3-索引优先队列" class="headerlink" title="5.3 索引优先队列"></a>5.3 索引优先队列</h5><p>​    之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一 个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的 基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。</p><p><strong>实现思路</strong>：</p><p><strong>步骤一：</strong> </p><p>​    存储数据时，给每一个数据元素关联一个整数，例如insert(int k,T t),我们可以看做k是t关联的整数，那么我们的实 现需要通过k这个值，快速获取到队列中t这个元素，此时有个k这个值需要具有唯一性。 </p><p>​    最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是 items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到 items[k]即可。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120134310151.png" alt="步骤一"></p><p><strong>步骤二：</strong></p><p>​     步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是， items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来 保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等 于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120134349004.png" alt="步骤二"></p><p><strong>步骤三：</strong> </p><p>​    通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要 对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整 pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需 要挑中pq[9]中元素的位置呢？</p><pre><code> 最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可， 但是效率很低。 </code></pre><p>​    我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如：<br>​            在pq数组中：pq[1]=6;<br>​            那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1;</p><p>​         <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120134517193.png" alt="步骤三"></p><p>​    有了pq数组后，如果我们修改items[0]=”H”，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]=9, 那么直接调整pq[9]即可。</p><p>代码实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>heap</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储堆中的元素</span>    <span class="token keyword">private</span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>    <span class="token comment">//保存每个元素在items数组中的索引，pq数组需要堆有序</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pq<span class="token punctuation">;</span>    <span class="token comment">//保存qp的逆序，pq的值作为索引，pq的索引作为值</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> qp<span class="token punctuation">;</span>    <span class="token comment">//记录堆中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        qp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>capacity <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> qp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//默认情况下，qp逆序中不保存任何索引</span>            qp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取队列中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断堆中索引i处的元素是否小于索引j处的元素</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//先通过pq找出items中的索引，然后再找出items中的元素进行对比</span>        <span class="token keyword">return</span> items<span class="token punctuation">[</span>pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//交换堆中i索引和j索引处的值</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//先交换pq数组中的值</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token comment">//更新qp数组中的值</span>        qp<span class="token punctuation">[</span>pq<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        qp<span class="token punctuation">[</span>pq<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断k对应的元素是否存在</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//默认情况下，qp的所有元素都为-1，如果某个位置插入了数据，则不为-1</span>        <span class="token keyword">return</span> qp<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//最小元素关联的索引</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//pq的索引1处，存放的是最小元素在items中的索引</span>        <span class="token keyword">return</span> pq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//往队列中插入一个元素,并关联索引i</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果索引i处已经存在了元素，则不让插入</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"该索引已经存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//个数+1</span>        <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//把元素存放到items数组中</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//使用pq存放i这个索引</span>        pq<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token comment">//在qp的i索引处存放N</span>        qp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">N</span><span class="token punctuation">;</span><span class="token comment">//上浮items[pq[N]],让pq堆有序</span>        <span class="token function">swim</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除队列中最小的元素,并返回该元素关联的索引</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//找到items中最小元素的索引</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> pq<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//交换pq中索引1处的值和N处的值</span>        <span class="token function">exch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除qp中索引pq[N]处的值</span>        qp<span class="token punctuation">[</span>pq<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除pq中索引N处的值</span>        pq<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除items中的最小元素</span>        items<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//元素数量-1</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//对pq[1]做下沉，让堆有序</span>        <span class="token function">sink</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> minIndex<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//删除索引i关联的元素</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//找出i在pq中的索引</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> qp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//把pq中索引k处的值和索引N处的值交换</span>        <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除qp中索引pq[N]处的值</span>        qp<span class="token punctuation">[</span>pq<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除pq中索引N处的值</span>        pq<span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//删除items中索引i处的值</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token comment">//元素数量-1</span>        <span class="token class-name">N</span><span class="token operator">--</span><span class="token punctuation">;</span><span class="token comment">//对pq[k]做下沉，让堆有序</span>        <span class="token function">sink</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对pq[k]做上浮，让堆有序</span>        <span class="token function">swim</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//把与索引i关联的元素修改为为t</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">changeItem</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token class-name">T</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//修改items数组中索引i处的值为t</span>        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token comment">//找到i在pq中的位置</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> qp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//对pq[k]做下沉，让堆有序</span>        <span class="token function">sink</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//对pq[k]做上浮，让堆有序</span>        <span class="token function">swim</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swim</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果已经到了根结点，则结束上浮</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//比较当前结点和父结点，如果当前结点比父结点小，则交换位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            k <span class="token operator">=</span> k <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sink</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果当前结点已经没有子结点了，则结束下沉</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">&lt;=</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//找出子结点中的较小值</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> <span class="token class-name">N</span> <span class="token operator">&amp;&amp;</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果当前结点的值比子结点中的较小值小，则结束</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">exch</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> min<span class="token punctuation">)</span><span class="token punctuation">;</span>            k <span class="token operator">=</span> min<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-树的进阶"><a href="#6-树的进阶" class="headerlink" title="6.树的进阶"></a>6.树的进阶</h3><h5 id="6-1平衡树"><a href="#6-1平衡树" class="headerlink" title="6.1平衡树"></a>6.1平衡树</h5><p>​    之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，大部分情况下，确实是 这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。</p><p>​     例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据，那么最终构造出来的树是长得下面这个样子：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120135153503.png" alt="特殊二叉树"></p><p>​    我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向 左边分支，如果我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情 况下，查找的效率依旧会很好。</p><h5 id="6-2-2-3查找树"><a href="#6-2-2-3查找树" class="headerlink" title="6.2  2-3查找树"></a>6.2  <strong>2-3查找树</strong></h5><p>​    为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我 们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和 三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。</p><h6 id="6-2-1-2-3查找树的定义"><a href="#6-2-1-2-3查找树的定义" class="headerlink" title="6.2.1  2-3查找树的定义"></a>6.2.1  2-3查找树的定义</h6><p>一棵2-3查找树要么为空，要么满足满足下面两个要求：</p><ul><li><strong>2-结点：</strong><br> 含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大 于该结点。</li><li><strong>3-结点：</strong><br> 含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都 位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151230360.png" alt="2-3查找树"></p><h6 id="6-2-2-2-3查找树的查找"><a href="#6-2-2-2-3查找树的查找" class="headerlink" title="6.2.2 2-3查找树的查找"></a>6.2.2 2-3查找树的查找</h6><p>​        将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和 根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连 接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151348109.png" alt="查找"></p><h6 id="6-2-3-2-3查找树的-插入"><a href="#6-2-3-2-3查找树的-插入" class="headerlink" title="6.2.3 2-3查找树的 插入"></a>6.2.3 2-3查找树的 插入</h6><ol><li>向2-结点中插入新键<pre><code>   往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之 所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一 个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节 点结束于一个3-结点，那么可能有点麻烦。</code></pre> <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151612695.png" alt="向2-结点中插入新键"></li><li>向一棵只含有一个3-结点的树中插入新键<pre><code> 假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结 点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升， 左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。</code></pre> <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151704484.png" alt="向一棵只含有一个3-结点的树中插入新键"></li><li>向一个父结点为2-结点的3-结点中插入新键<pre><code>   和上面的情况一样一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中 的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位 置。</code></pre> <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151736177.png" alt="向一个父结点为2-结点的3-结点中插入新键"></li><li>向一个父结点为3-结点的3-结点中插入新键<pre><code> 当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点， 插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其 变为3-结点，不需要继续进行拆分。</code></pre> <img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120151845871.png" alt="向一个父结点为3-结点的3-结点中插入新键"><br> 之后的过程同第三项</li><li>分解根结点<pre><code> 当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会编程一个临时的4-结点，此时，就需要将 根结点拆分为两个2-结点，树的高度加1。</code></pre></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120152002527.png" alt="分解根结点"></p><h6 id="6-2-4-2-3树的性质"><a href="#6-2-4-2-3树的性质" class="headerlink" title="6.2.4  2-3树的性质"></a>6.2.4  2-3树的性质</h6><p>​    通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。 一棵完全平衡的2-3树具有以下性质：</p><ol><li><p>任意空链接到根结点的路径长度都是相等的。 </p></li><li><p>4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1</p></li><li><p>2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。</p></li></ol><h6 id="6-2-5-2-3树的实现"><a href="#6-2-5-2-3树的实现" class="headerlink" title="6.2.5  2-3树的实现"></a>6.2.5  2-3树的实现</h6><p>​    直接实现2-3树比较复杂，因为： </p><ul><li>需要处理不同的结点类型，非常繁琐； </li><li>需要多次比较操作来将结点下移； </li><li>需要上移来拆分4-结点； </li><li>拆分4-结点的情况有很多种；</li></ul><p>​     2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重 要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。</p><h5 id="6-3-红黑树"><a href="#6-3-红黑树" class="headerlink" title="6.3 红黑树"></a>6.3 红黑树</h5><p>​    我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点 都是2-结点，树的高度为lgN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的 时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。</p><p>​     红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信 息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：<br>​     <strong>红链接</strong>：将两个2-结点连接起来构成一个3-结点；<br>​    <strong>黑链接</strong>：则是2-3树中的普通链接。</p><p> 确切的说，我们将3-结点表示为由由一条<strong>左斜</strong>的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2- 结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120152357743.png" alt="红黑树"></p><h6 id="6-3-1-红黑树的定义"><a href="#6-3-1-红黑树的定义" class="headerlink" title="6.3.1  红黑树的定义"></a>6.3.1  红黑树的定义</h6><p>红黑树是含有红黑链接并满足下列条件的二叉查找树：</p><ol><li><p>红链接均为左链接； </p></li><li><p>没有任何一个结点同时和两条红链接相连； </p></li><li><p>该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同； </p><p>下面是红黑树与2-3树的对应关系：</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120152604523.png" alt="红黑树与2-3树的对应关系"></p><h6 id="6-3-2红黑树的结点"><a href="#6-3-2红黑树的结点" class="headerlink" title="6.3.2红黑树的结点"></a>6.3.2红黑树的结点</h6><p>​    因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的Node结点中添加一个布 尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色 的，那么该变量的值为false。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120152659780.png" alt="红黑树的结点"></p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">,</span><span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>    <span class="token comment">//存储键</span>    <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>    <span class="token comment">//存储值</span>    <span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>    <span class="token comment">//记录左子结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>    <span class="token comment">//记录右子结点</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>    <span class="token comment">//由其父结点指向它的链接的颜色</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span><span class="token class-name">Node</span> right<span class="token punctuation">,</span><span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="6-3-3-平衡化"><a href="#6-3-3-平衡化" class="headerlink" title="6.3.3 平衡化"></a>6.3.3 平衡化</h6><p>​    在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足 红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。</p><h6 id="6-3-3-1-左旋"><a href="#6-3-3-1-左旋" class="headerlink" title="6.3.3.1 左旋"></a>6.3.3.1 左旋</h6><p>​    当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。</p><p>​     <strong>前提</strong>：当前结点为h，它的右子结点为x；</p><p>​     <strong>左旋过程：</strong> </p><ol><li>让x的左子结点变为h的右子结点：h.right=x.left; </li><li>让h成为x的左子结点：x.left=h; </li><li>让h的color属性变为x的color属性值：x.color=h.color; </li><li>让h的color属性变为RED：h.color=true;</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153057890.png" alt="左旋"></p><h6 id="6-3-3-1-右旋"><a href="#6-3-3-1-右旋" class="headerlink" title="6.3.3.1 右旋"></a>6.3.3.1 右旋</h6><p>当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋 </p><p><strong>前提</strong>：当前结点为h，它的左子结点为x； </p><p><strong>右旋过程</strong>： </p><ol><li>让x的右子结点成为h的左子结点：h.left = x.right; </li><li>让h成为x的右子结点：x.right=h; </li><li>让x的color变为h的color属性值：x.color = h.color; </li><li>让h的color为RED；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153216650.png" alt="右旋"></p><h6 id="6-3-3-1颜色反转"><a href="#6-3-3-1颜色反转" class="headerlink" title="6.3.3.1颜色反转"></a>6.3.3.1颜色反转</h6><p>​    当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子 结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153328424.png" alt="颜色反转"></p><h6 id="6-3-4-1-向单个2-结点中插入新键"><a href="#6-3-4-1-向单个2-结点中插入新键" class="headerlink" title="6.3.4.1 向单个2-结点中插入新键"></a>6.3.4.1 向单个2-结点中插入新键</h6><p>一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。</p><ul><li>​     如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153441302.png" alt="1"></p><ul><li>如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把 红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红 色链接。</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153506763.png" alt="2"></p><h6 id="6-3-4-2-向底部的2-结点插入新键"><a href="#6-3-4-2-向底部的2-结点插入新键" class="headerlink" title="6.3.4.2 向底部的2-结点插入新键"></a>6.3.4.2 向底部的2-结点插入新键</h6><p>​    用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一 区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方 式仍然适用。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153555036.png" alt="向底部的2-结点插入新键"></p><h6 id="6-3-4-3-向一棵双键树-即一个3-结点-中插入新键"><a href="#6-3-4-3-向一棵双键树-即一个3-结点-中插入新键" class="headerlink" title="6.3.4.3 向一棵双键树(即一个3-结点)中插入新键"></a>6.3.4.3 向一棵双键树(即一个3-结点)中插入新键</h6><p>这种情况有可以分为三种子情况：</p><ol><li>新键大于原树中的两个键<br><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153731059.png" alt="1"></li><li>新键小于原树中的两个键<br><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153747423.png" alt="2"></li><li>新键介于原数中两个键之间<br><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153809114.png" alt="3"></li></ol><h6 id="6-3-4-4-根结点的颜色总是黑色"><a href="#6-3-4-4-根结点的颜色总是黑色" class="headerlink" title="6.3.4.4 根结点的颜色总是黑色"></a>6.3.4.4 根结点的颜色总是黑色</h6><p>之前我们介绍结点API的时候，在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根 结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。</p><h6 id="6-3-4-5-向树底部的3-结点插入新键"><a href="#6-3-4-5-向树底部的3-结点插入新键" class="headerlink" title="6.3.4.5 向树底部的3-结点插入新键"></a>6.3.4.5 向树底部的3-结点插入新键</h6><p>​    假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是 3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链 接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结 点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点 为止。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153935346.png" alt="1"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120153946888.png" alt="2"></p><h6 id="6-3-5-代码实现："><a href="#6-3-5-代码实现：" class="headerlink" title="6.3.5 代码实现："></a>6.3.5 代码实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>tree</span><span class="token punctuation">;</span><span class="token comment">//红黑树代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedBlackTree</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Key</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token punctuation">&lt;</span><span class="token class-name">Key</span><span class="token punctuation">&gt;</span><span class="token punctuation">,</span> <span class="token class-name">Value</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span><span class="token comment">//根节点</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> root<span class="token punctuation">;</span>    <span class="token comment">//记录树中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token comment">//红色链接</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> RED <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment">//黑色链接</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> BLACK <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 判断当前节点的父指向链接是否为红色     *     * @param x     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isRed</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//空结点默认是黑色链接</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//非空结点需要判断结点color属性的值</span>        <span class="token keyword">return</span> x<span class="token punctuation">.</span>color <span class="token operator">==</span> RED<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 左旋转     *     * @param     * @return     */</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span><span class="token class-name">Node</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//找出当前结点h的右子结点</span>        <span class="token class-name">Node</span> hRight <span class="token operator">=</span> h<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token comment">//找出右子结点的左子结点</span>        <span class="token class-name">Node</span> lhRight <span class="token operator">=</span> hRight<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的右子结点的左子结点成为当前结点的右子结点</span>        h<span class="token punctuation">.</span>right <span class="token operator">=</span> lhRight<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h称为右子结点的左子结点</span>        hRight<span class="token punctuation">.</span>left <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的color编程右子结点的color</span>        hRight<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的color变为RED</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token comment">//返回当前结点的右子结点</span>        <span class="token keyword">return</span> hRight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 右旋     *     * @param h     * @return     */</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span><span class="token class-name">Node</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//找出当前结点h的左子结点</span>        <span class="token class-name">Node</span> hLeft <span class="token operator">=</span> h<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token comment">//找出当前结点h的左子结点的右子结点</span>        <span class="token class-name">Node</span> rHleft <span class="token operator">=</span> hLeft<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的左子结点的右子结点称为当前结点的左子结点</span>        h<span class="token punctuation">.</span>left <span class="token operator">=</span> rHleft<span class="token punctuation">;</span>        <span class="token comment">//让当前结点称为左子结点的右子结点</span>        hLeft<span class="token punctuation">.</span>right <span class="token operator">=</span> h<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的color值称为左子结点的color值</span>        hLeft<span class="token punctuation">.</span>color <span class="token operator">=</span> h<span class="token punctuation">.</span>color<span class="token punctuation">;</span>        <span class="token comment">//让当前结点h的color变为RED</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token comment">//返回当前结点的左子结点</span>        <span class="token keyword">return</span> hLeft<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 颜色反转,相当于完成拆分4-节点     *     * @param h     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">flipColors</span><span class="token punctuation">(</span><span class="token class-name">Node</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//当前结点的color属性值变为RED；</span>        h<span class="token punctuation">.</span>color <span class="token operator">=</span> RED<span class="token punctuation">;</span>        <span class="token comment">//当前结点的左右子结点的color属性值都变为黑色</span>        h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>        h<span class="token punctuation">.</span>right<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 在整个树上完成插入操作     *     * @param key     * @param val     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//在root整个树上插入key-val</span>        root <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//让根结点的颜色变为BLACK</span>        root<span class="token punctuation">.</span>color <span class="token operator">=</span> BLACK<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 在指定树中，完成插入操作,并返回添加元素后新的树     *     * @param h     * @param key     * @param val     */</span>    <span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Node</span> h<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//标准的插入操作，和父结点用红链接相连</span>            <span class="token class-name">N</span><span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> RED<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//比较要插入的键和当前结点的键</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//继续寻找左子树插入</span>            h<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//继续寻找右子树插入</span>            h<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">put</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//已经有相同的结点存在，修改节点的值；</span>            h<span class="token punctuation">.</span>value <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果当前结点的右链接是红色，左链接是黑色，需要左旋</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果当前结点的左子结点和左子结点的左子结点都是红色链接，则需要右旋</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            h <span class="token operator">=</span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果当前结点的左链接和右链接都是红色，需要颜色变换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isRed</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">flipColors</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//返回当前结点</span>        <span class="token keyword">return</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//根据key，从树中找出对应的值</span>    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//从指定的树x中，查找key对应的值</span>    <span class="token keyword">public</span> <span class="token class-name">Value</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">,</span> <span class="token class-name">Key</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果当前结点为空，则没有找到,返回null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//比较当前结点的键和key</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；</span>            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；</span>            <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//如果要查询的key等于当前结点的key，则树中返回当前结点的value。</span>            <span class="token keyword">return</span> x<span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取树中元素的个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">N</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//结点类</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token comment">//存储键</span>        <span class="token keyword">public</span> <span class="token class-name">Key</span> key<span class="token punctuation">;</span>        <span class="token comment">//存储值</span>        <span class="token keyword">private</span> <span class="token class-name">Value</span> value<span class="token punctuation">;</span>        <span class="token comment">//记录左子结点</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> left<span class="token punctuation">;</span>        <span class="token comment">//记录右子结点</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span> right<span class="token punctuation">;</span>        <span class="token comment">//由其父结点指向它的链接的颜色</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> color<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Key</span> key<span class="token punctuation">,</span> <span class="token class-name">Value</span> value<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">,</span> <span class="token keyword">boolean</span> color<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="6-4-B树"><a href="#6-4-B树" class="headerlink" title="6.4 B树"></a>6.4 B树</h5><p>​    前面我们已经学习了二叉查找树、2-3树以及它的实现红黑树。2-3树中，一个结点做多能有两个key，它的实现红 黑树中使用对链接染色的方式去表达这两个key。接下来我们学习另外一种树型结构B树，这种数据结构中，一个结 点允许多于两个key的存在。</p><p>​    B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插 入和删除等操作。</p><h6 id="6-4-1-B树的特性"><a href="#6-4-1-B树的特性" class="headerlink" title="6.4.1 B树的特性"></a>6.4.1 B树的特性</h6><p>​    B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选 择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：</p><ul><li>每个结点最多有M-1个key，并且以升序排列； </li><li>每个结点最多能有M个子结点； </li><li>根结点至少有两个子结点；</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161239020.png" alt="B树"></p><p>在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这 样在某些应用场景下，就可以体现出它的优势。</p><h6 id="6-4-2-B树存储数据"><a href="#6-4-2-B树存储数据" class="headerlink" title="6.4.2 B树存储数据"></a>6.4.2 B树存储数据</h6><p>若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161523149.png" alt="1"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161541238.png" alt="2"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161554313.png" alt="3"></p><h6 id="6-4-3-B树在磁盘文件中的应用"><a href="#6-4-3-B树在磁盘文件中的应用" class="headerlink" title="6.4.3 B树在磁盘文件中的应用"></a>6.4.3 B树在磁盘文件中的应用</h6><p>​    在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是 通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。</p><p><strong>磁盘</strong></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161721658.png" alt="磁盘"></p><p> <strong>磁盘IO</strong></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161752663.png" alt=" 磁盘IO"></p><p>​    由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘 I/O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字 节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的 局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻 道时间，只需很少的旋转时间），因此预读可以提高I/O效率。</p><p>​    页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储 块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程 序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位 置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>​    文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每 个结点只需要一次I/O就可以完全载入。那么3层的B树可以容纳1024<em>1024</em>1024差不多10亿个数据，如果换成二 叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查 找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效 率。</p><h5 id="6-5-B-树"><a href="#6-5-B-树" class="headerlink" title="6.5 B+树"></a>6.5 B+树</h5><p>B+树是对B树的一种变形树，它与B树的差异在于： </p><ol><li> 非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value； </li><li> 树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。</li></ol><h6 id="6-5-1-B-树存储数据"><a href="#6-5-1-B-树存储数据" class="headerlink" title="6.5.1  B+树存储数据"></a>6.5.1  B+树存储数据</h6><p>若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120161956454.png" alt="1"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120162025966.png" alt="2"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120162039838.png" alt="3"></p><h6 id="6-5-2-B-树和B树的对比"><a href="#6-5-2-B-树和B树的对比" class="headerlink" title="6.5.2 B+树和B树的对比"></a>6.5.2 B+树和B树的对比</h6><p><strong>B+ 树的优点在于：</strong></p><ol><li><p>由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的 key。 </p></li><li><p>B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序 排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。</p></li></ol><p><strong>B树的优点在于：</strong></p><p>由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到 value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶 子结点的深度，才能找到value。</p><h6 id="6-5-3-B-树在数据库中的应用"><a href="#6-5-3-B-树在数据库中的应用" class="headerlink" title="6.5.3 B+树在数据库中的应用"></a>6.5.3 B+树在数据库中的应用</h6><p>​    在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题， 在很多数据库中，都是用到了B+树来提高查询的效率；</p><pre><code> 在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这 个索引就是B+树这种数据结构实现的。</code></pre><p><strong>未建立主键索引查询</strong></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120162248455.png" alt="未建立主键索引查询"></p><p> <strong>建立主键索引查询</strong></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211120162312537.png" alt=" 建立主键索引查询"></p><p><strong>区间查询</strong></p><p>​    执行 select * from user where id&gt;=12 and id&lt;=18 ,如果有了索引，由于B+树的叶子结点形成了一个有序链表， 所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。</p><h3 id="7-并查集"><a href="#7-并查集" class="headerlink" title="7.并查集"></a>7.并查集</h3><p>并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作：</p><ul><li>查询元素p和元素q是否属于同一组</li><li>合并元素p和元素q所在的组</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160034662.png" alt="并查集"></p><h5 id="7-1-并查集结构"><a href="#7-1-并查集结构" class="headerlink" title="7.1 并查集结构"></a>7.1 并查集结构</h5><p>并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：</p><ol><li> 每个元素都唯一的对应一个结点；</li><li>. 每一组数据中的多个元素都在同一颗树中；</li><li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；</li><li>元素在树中并没有子父级关系的硬性要求；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160149898.png" alt="并查集结构"></p><h5 id="7-2并查集实现"><a href="#7-2并查集实现" class="headerlink" title="7.2并查集实现"></a>7.2并查集实现</h5><p><strong>UF(int N)构造方法实现</strong></p><ol><li>初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；</li><li>初始化数组eleAndGroup；</li><li>把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点 所在的分组，那么初始化情况下，i索引处存储的值就是i</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160324058.png" alt="构造方法实现"></p><p><strong>union(int p,int q)合并方法实现</strong></p><ol><li>.如果p和q已经在同一个分组中，则无需合并</li><li>. 如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即 可</li><li>分组数量-1</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160442316.png" alt="合并方法实现"></p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//并查集代码</span><span class="token keyword">public</span> <span class="token keyword">class</span> UF <span class="token punctuation">{</span>    <span class="token comment">//记录结点元素和该元素所在分组的标识</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> eleAndGroup<span class="token punctuation">;</span>    <span class="token comment">//记录并查集中数据的分组个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//初始化并查集</span>    <span class="token keyword">public</span> <span class="token function">UF</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token class-name">N</span><span class="token punctuation">;</span>        <span class="token comment">//初始化数组</span>        eleAndGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eleAndGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取当前并查集中的数据有多少个分组</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//元素p所在分组的标识符</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> eleAndGroup<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断并查集中元素p和元素q是否在同一分组中</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//把p元素所在分组和q元素所在分组合并</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//如果p和q已经在同一个分组中，则无需合并；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">connected</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识</span>        符即可        <span class="token keyword">int</span> pGroup <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> qGroup <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> eleAndGroup<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eleAndGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>pGroup<span class="token punctuation">)</span><span class="token punctuation">{</span>            eleAndGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>qGroup<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//分组数量-1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-3-并查集应用举例"><a href="#7-3-并查集应用举例" class="headerlink" title="7.3 并查集应用举例"></a>7.3 并查集应用举例</h5><p>​    如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则我们就可以通过connected(int p,int q)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通 信，此时我们又可以调用union(int p,int q)使得p和q之间连通，这样两台计算机之间就可以通信了。</p><p>​    一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多 次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少 要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之 前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优 化。</p><h5 id="7-4-UF-Tree算法优化"><a href="#7-4-UF-Tree算法优化" class="headerlink" title="7.4 UF_Tree算法优化"></a>7.4 UF_Tree算法优化</h5><p>​    为了提升union算法的性能，我们需要重新设计find方法和union方法的实现，此时我们先需要对我们的之前数据结 构中的eleAndGourp数组的含义进行重新设定：</p><ol><li>我们仍然让eleAndGroup数组的索引作为某个结点的元素；</li><li>eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160752435.png" alt="UF_Tree算法优化"></p><p><strong>find(int p)查询方法实现</strong></p><ol><li>判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；</li><li>如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121160906467.png" alt="查询方法实现"></p><p><strong>union(int p,int q)合并方法实现</strong></p><ol><li><p>找到p元素所在树的根结点 </p></li><li><p>找到q元素所在树的根结点 </p></li><li><p>如果p和q已经在同一个树中，则无需合并； </p></li><li><p>如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可； </p></li><li><p>分组数量-1</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121161035568.png" alt="合并方法实现"></p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UF_Tree</span> <span class="token punctuation">{</span>    <span class="token comment">//记录结点元素和该元素所的父结点</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> eleAndGroup<span class="token punctuation">;</span>    <span class="token comment">//记录并查集中数据的分组个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//初始化并查集</span>    <span class="token keyword">public</span> <span class="token class-name">UF_Tree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token class-name">N</span><span class="token punctuation">;</span>        <span class="token comment">//初始化数组</span>        eleAndGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点的父结点，那么初始化情况下，i索引处存储的值就是i</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            eleAndGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取当前并查集中的数据有多少个分组</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//元素p所在分组的标识符</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>eleAndGroup<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根</span>        结点为止；        p<span class="token operator">=</span>eleAndGroup<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断并查集中元素p和元素q是否在同一分组中</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//把p元素所在分组和q元素所在分组合并</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//找到p元素所在树的根结点</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//找到q元素所在树的根结点</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果p和q已经在同一个树中，则无需合并；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot<span class="token operator">==</span>qRoot<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；</span>        eleAndGroup<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token operator">=</span>qRoot<span class="token punctuation">;</span>        <span class="token comment">//分组数量-1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>优化后的性能分析</strong></p><p>​    我们优化后的算法union，如果要把并查集中所有的数据连通，仍然至少要调用N-1次union方法，但是，我们发现 union方法中已经没有了for循环，所以union算法的时间复杂度由O(N^2)变为了O(N)。</p><p>​    但是这个算法仍然有问题，因为我们之前不仅修改了union算法，还修改了find算法。我们修改前的find算法的时 间复杂度在任何情况下都为O(1)，但修改后的find算法在最坏情况下是O(N)：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121161314997.png" alt="优化后的性能分析"></p><p>​    在union方法中调用了find方法，所以在最坏情况下union算法的时间复杂度仍然为O(N^2)。</p><h5 id="7-5-路径压缩"><a href="#7-5-路径压缩" class="headerlink" title="7.5 路径压缩"></a>7.5 路径压缩</h5><p>​    UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大 小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化find方法。</p><p>​    之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果 我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小 树的深度。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121161411625.png" alt="路径压缩"></p><p>​    只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高find方法的效 率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码 调整数组中的值。</p><p><strong>代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UF_Tree_Weighted</span> <span class="token punctuation">{</span>    <span class="token comment">//记录结点元素和该元素所的父结点</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> eleAndGroup<span class="token punctuation">;</span>    <span class="token comment">//存储每个根结点对应的树中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sz<span class="token punctuation">;</span>    <span class="token comment">//记录并查集中数据的分组个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//初始化并查集</span>    <span class="token keyword">public</span> <span class="token class-name">UF_Tree_Weighted</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">=</span><span class="token class-name">N</span><span class="token punctuation">;</span>        <span class="token comment">//初始化数组</span>        eleAndGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        sz <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该</span>        结点的父结点，那么初始化情况下，i索引处存储的值就是i        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        eleAndGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//把sz数组中所有的元素初始化为1，默认情况下，每个结点都是一个独立的树，每个树中只有一个元素</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        sz<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取当前并查集中的数据有多少个分组</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//元素p所在分组的标识符</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">==</span>eleAndGroup<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；</span>            p<span class="token operator">=</span>eleAndGroup<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断并查集中元素p和元素q是否在同一分组中</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">connected</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">==</span><span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//把p元素所在分组和q元素所在分组合并</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">union</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//找到p元素所在树的根结点</span>        <span class="token keyword">int</span> pRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//找到q元素所在树的根结点</span>        <span class="token keyword">int</span> qRoot <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果p和q已经在同一个树中，则无需合并；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pRoot<span class="token operator">==</span>qRoot<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果p和q不在同一个分组，比较p所在树的元素个数和q所在树的元素个数,把较小的树合并到较大的树</span>        上        <span class="token keyword">if</span> <span class="token punctuation">(</span>sz<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token operator">&lt;</span>sz<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            eleAndGroup<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span> <span class="token operator">=</span> qRoot<span class="token punctuation">;</span>            <span class="token comment">//重新调整较大树的元素个数</span>            sz<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token operator">+=</span>sz<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            eleAndGroup<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token operator">=</span>pRoot<span class="token punctuation">;</span>            sz<span class="token punctuation">[</span>pRoot<span class="token punctuation">]</span><span class="token operator">+=</span>sz<span class="token punctuation">[</span>qRoot<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//分组数量-1</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-6-案例-畅通工程"><a href="#7-6-案例-畅通工程" class="headerlink" title="7.6 案例-畅通工程"></a>7.6 案例-畅通工程</h5><p>​    某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目 标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问 最少还需要建设多少条道路？</p><p>在我们的测试数据文件夹中有一个trffic_project.txt文件，它就是诚征道路统计表，下面是对数据的解释：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121161644108.png" alt="数据的解释"></p><p>总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？</p><p><strong>解题思路</strong>：</p><ol><li>创建一个并查集UF_Tree_Weighted(20)</li><li>分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的 道路把对应的城市连接起来；</li><li>.如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前 并查集中剩余的数目，减去1，就是还需要修建的道路数目；</li></ol><p><strong>代码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Traffic_Project</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//创建输入流</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span>        <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">Traffic_Project</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"traffic_project.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取城市数目，初始化并查集</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UF_Tree_Weighted</span> uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UF_Tree_Weighted</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取已经修建好的道路数目</span>        <span class="token keyword">int</span> roadNumber <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//循环读取已经修建好的道路，并调用union方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> roadNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            uf<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//获取剩余的分组数量</span>        <span class="token keyword">int</span> groupNumber <span class="token operator">=</span> uf<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//计算出还需要修建的道路</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"还需要修建"</span><span class="token operator">+</span><span class="token punctuation">(</span>groupNumber<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"道路，城市才能相通"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-图的入门"><a href="#8-图的入门" class="headerlink" title="8.图的入门"></a>8.图的入门</h3><h5 id="8-1介绍"><a href="#8-1介绍" class="headerlink" title="8.1介绍"></a>8.1介绍</h5><p>​    在现实生活中，有许多应用场景会包含很多点以及点点之间的连接，而这些应用场景我们都可以用即将要学习的图 这种数据结构去解决。</p><p> <strong>图的定义及分类</strong></p><p><strong>定义</strong>：图是由一组顶点和一组能够将两个顶点相连的边组成的</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121193436584.png" alt="图"></p><p><strong>特殊的图：</strong></p><ol><li>自环：即一条连接一个顶点和其自身的边；</li><li> 平行边：连接同一对顶点的两条边；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121193511243.png" alt="特殊的图"></p><p><strong>图的分类：</strong></p><p>按照<strong>连接两个顶点的边的不同</strong>，可以把图分为以下两种：</p><ul><li> <strong>无向图</strong>：边仅仅连接两个顶点，没有其他含义；</li><li> <strong>有向图</strong>：边不仅连接两个顶点，并且具有方向；</li></ul><p><strong>图的相关术语</strong></p><ul><li><strong>相邻顶点：</strong> 当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 </li><li><strong>度：</strong> 某个顶点的度就是依附于该顶点的边的个数 </li><li><strong>子图：</strong> 是一幅图的所有边的子集(包含这些边依附的顶点)组成的图； </li><li><strong>路径</strong>： 是由边顺序连接的一系列的顶点组成 </li><li><strong>环</strong>： 是一条至少含有一条边且终点和起点相同的路径 </li><li><strong>连通图</strong>： 如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图</li><li><strong>连通子图</strong>： 一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图</li></ul><h5 id="8-2图的存储结构"><a href="#8-2图的存储结构" class="headerlink" title="8.2图的存储结构"></a>8.2图的存储结构</h5><p>要表示一幅图，只需要表示清楚以下两部分内容即可： </p><ol><li>图中所有的顶点； </li><li>所有连接顶点的边； </li></ol><p>常见的图的存储结构有两种：邻接矩阵和邻接表</p><p><strong>邻接矩阵</strong></p><ol><li><p>使用一个V*V的二维数组int[V] [V] adj,把索引的值看做是顶点;</p></li><li><p>如果顶点v和顶点w相连，我们只需要将adj[v] [w]和adj[w] [v]的值设置为1,否则设置为0即可。</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121194026223.png" alt="邻接矩阵"></p><p>​    很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能 不够用。</p><p><strong>邻接表</strong></p><ol><li><p>使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点； </p></li><li><p>每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121194104293.png" alt="邻接表"></p><p>很明显，邻接表的空间并不是是线性级别的，所以后面我们一直采用邻接表这种存储形式来表示图。</p><h5 id="8-3图的实现"><a href="#8-3图的实现" class="headerlink" title="8.3图的实现"></a>8.3图的实现</h5><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Graph</span> <span class="token punctuation">{</span>    <span class="token comment">//顶点数目</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token comment">//边的数目</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token comment">//邻接表</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//初始化顶点数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span>        <span class="token comment">//初始化边的数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表中的空队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取顶点数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边的数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向图中添加一条边 v-w</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//把w添加到v的链表中，这样顶点v就多了一个相邻点w</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//把v添加到w的链表中，这样顶点w就多了一个相邻点v</span>        adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//边的数目自增1</span>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取和顶点v相邻的所有顶点</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">adj</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-4-图的搜索"><a href="#8-4-图的搜索" class="headerlink" title="8.4  图的搜索"></a>8.4  图的搜索</h5><p>在很多情况下，我们需要遍历图，得到图的一些性质，例如，找出图中与指定的顶点相连的所有顶点，或者判定某 个顶点与指定顶点是否相通，是非常常见的需求。 </p><p>有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，</p><h6 id="8-4-1-深度优先搜索"><a href="#8-4-1-深度优先搜索" class="headerlink" title="8.4.1  深度优先搜索"></a>8.4.1  深度优先搜索</h6><p>​    所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找 兄弟结点。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121194318657.png" alt="深度优先搜索"></p><p>​    很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相 邻链表中，那么为了不对顶点进行重复搜索，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布 尔类型的数组 boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true， 如果没有搜索，标记为false；</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstSearch</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//记录有多少个顶点与s顶点相通</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点</span>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstSearch</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//创建一个和图的顶点数一样大小的布尔数组</span>    marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//搜索G图中与顶点s相同的所有顶点</span>    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用深度优先搜索找出G图中v顶点的所有相邻顶点</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//把当前顶点标记为已搜索</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//遍历v顶点的邻接表，得到每一个顶点w</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//相通的顶点数量+1</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断w顶点与s顶点是否相通</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">marked</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取与顶点s相通的所有顶点的总数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="8-4-2-广度优先搜索"><a href="#8-4-2-广度优先搜索" class="headerlink" title="8.4.2 广度优先搜索"></a>8.4.2 广度优先搜索</h6><p>​    所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后 找子结点。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121194529457.png" alt="广度优先搜索"></p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BreadthFirstSearch</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//记录有多少个顶点与s顶点相通</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment">//用来存储待搜索邻接表的点</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> waitSearch<span class="token punctuation">;</span>        <span class="token comment">//构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点</span>    <span class="token keyword">public</span> <span class="token class-name">BreadthFirstSearch</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的布尔数组</span>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化待搜索顶点的队列</span>        waitSearch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//搜索G图中与顶点s相同的所有顶点</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用广度优先搜索找出G图中v顶点的所有相邻顶点</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//把当前顶点v标记为已搜索</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//把当前顶点v放入到队列中，等待搜索它的邻接表</span>        waitSearch<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//使用while循环从队列中拿出待搜索的顶点wait，进行搜索邻接表</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>waitSearch<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                       <span class="token comment">//弹出一个待搜索的顶点</span>            <span class="token class-name">Integer</span> wait <span class="token operator">=</span> waitSearch<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//遍历wait顶点的邻接表</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> w<span class="token operator">:</span> graph<span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">// 该顶点还没被搜索过 对其进行搜索</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">marked</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    marked【w】 <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token comment">// 将节点放入堆栈中，用于后续的获取该节点的子节点</span>                    waitSearch<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//让相通的顶点+1；</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                     <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//相通的顶点数量+1</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断w顶点与s顶点是否相通</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">marked</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取与顶点s相通的所有顶点的总数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-5案例-畅通工程续1"><a href="#8-5案例-畅通工程续1" class="headerlink" title="8.5案例-畅通工程续1"></a>8.5案例-畅通工程续1</h5><p><strong>解题思路：</strong> </p><ol><li>创建一个图Graph对象，表示城市；</li><li>分别调用<br>addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)，表示已 经修建好的道路把对应的城市连接起来；</li><li>通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象；</li><li>.调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相 通。</li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">BufferedReader</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStreamReader</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Traffic_Project2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//创建输入流</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span>        <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">Traffic_Project2</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>"traffic_proje        ct<span class="token punctuation">.</span>txt"<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取城市数目，初始化Graph图</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Graph</span> <span class="token class-name">G</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Graph</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取已经修建好的道路数目</span>        <span class="token keyword">int</span> roadNumber <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//循环读取已经修建好的道路，并调用addEdge方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> roadNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                                                                                      <span class="token comment">//根据图G和顶点9构建图的搜索对象</span>        <span class="token comment">//BreadthFirstSearch search = new BreadthFirstSearch(G,9);</span>        <span class="token class-name">DepthFirstSearch</span> search <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DepthFirstSearch</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//调用搜索对象的marked(10)方法和marked(8)方法</span>        <span class="token keyword">boolean</span> flag1 <span class="token operator">=</span> search<span class="token punctuation">.</span><span class="token function">marked</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> flag2 <span class="token operator">=</span> search<span class="token punctuation">.</span><span class="token function">marked</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"9号城市和10号城市是否已相通："</span> <span class="token operator">+</span> flag1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"9号城市和8号城市是否已相通："</span> <span class="token operator">+</span> flag2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="8-6-路径查找"><a href="#8-6-路径查找" class="headerlink" title="8.6 路径查找"></a>8.6 路径查找</h5><p>​    在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地 城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是： 从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121203142370.png" alt="路径查找"></p><p>例如在上图上查找顶点0到顶点4的路径用红色标识出来,那么我们可以把该路径表示为 0-2-3-4。</p><p><strong>路径查找实现</strong></p><p>​    我们实现路径查找，最基本的操作还是得遍历并搜索图，所以，我们的实现暂且基于深度优先搜索来完成。其搜索 的过程是比较简单的。我们添加了edgeTo[]整型数组，这个整型数组会记录从每个顶点回到起点s的路径。 </p><p>如果我们把顶点设定为0，那么它的搜索可以表示为下图：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121203239932.png" alt="1"></p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211121203254891.png" alt="2"></p><p>根据最终edgeTo的结果，我们很容易能够找到从起点0到任意顶点的路径；</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstPaths</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//起点</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> s<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>    <span class="token comment">//构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径</span>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstPaths</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的布尔数组</span>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//创建一个和图顶点数一样大小的整型数组</span>        edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化顶点</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>s<span class="token operator">=</span>s<span class="token punctuation">;</span>        <span class="token comment">//搜索G图中起点为s的所有路径</span>        <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//使用深度优先搜索找出G图中v顶点的所有相邻顶点</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Graph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//把当前顶点标记为已搜索</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//遍历v顶点的邻接表，得到每一个顶点w</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点w没有被搜索过，则将edgeTo[w]设置为v,表示w的前一个顶点为v，并递归搜索与w顶</span>            点相通的其他顶点            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>v<span class="token punctuation">;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token comment">//判断w顶点与s顶点是否存在路径</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//找出从起点s到顶点v的路径(就是该路径经过的顶点)</span>    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">pathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//当前v顶点与s顶点不连通，所以直接返回null，没有路径</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPathTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment">//创建路劲中经过的顶点的容器</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//第一次把当前顶点存进去，然后将x变换为到达当前顶点的前一个顶点edgeTo[x],在把前一个顶点存进去，继续将x变化为到达前一个顶点的前一个顶点，继续存，一直到x的值为s为止，相当于逆推法，最后把s放进去</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> v<span class="token punctuation">;</span>x<span class="token operator">!=</span>s<span class="token punctuation">;</span>x<span class="token operator">=</span>edgeTo<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//把当前顶点放入容器</span>            path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//把起点s放入容器</span>        path<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> path<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-图的进阶"><a href="#9-图的进阶" class="headerlink" title="9.图的进阶"></a>9.图的进阶</h3><h5 id="9-1有向图"><a href="#9-1有向图" class="headerlink" title="9.1有向图"></a>9.1有向图</h5><p>​    在实际生活中，很多应用相关的图都是有方向性的，最直观的就是网络，可以从A页面通过链接跳转到B页面，那 么a和b连接的方向是a-&gt;b,但不能说是b-&gt;a,此时我们就需要使用有向图来解决这一类问题，它和我们之前学习的无 向图，最大的区别就在于连接是具有方向的，在代码的处理上也会有很大的不同。</p><h6 id="9-1-1有向图的定义及相关术语"><a href="#9-1-1有向图的定义及相关术语" class="headerlink" title="9.1.1有向图的定义及相关术语"></a>9.1.1有向图的定义及相关术语</h6><p><strong>定义</strong>： 有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。</p><ul><li><strong>出度</strong>： 由某个顶点指出的边的个数称为该顶点的出度。 </li><li><strong>入度：</strong> 指向某个顶点的边的个数称为该顶点的入度。 </li><li><strong>有向路径：</strong> 由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 </li><li><strong>有向环：</strong> 一条至少含有一条边，且起点和终点相同的有向路径。</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122111733841.png" alt="有向图"></p><p><strong>一副有向图中两个顶点v和w可能存在以下四种关系：</strong></p><ol><li>没有边相连；</li><li>存在从v到w的边v—&gt;w</li><li>存在从w到v的边w—&gt;v</li><li>既存在w到v的边，也存在v到w的边，即双向连接；</li></ol><h6 id="9-1-2-有向图实现"><a href="#9-1-2-有向图实现" class="headerlink" title="9.1.2 有向图实现"></a>9.1.2 有向图实现</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Digraph</span> <span class="token punctuation">{</span>    <span class="token comment">//顶点数目</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token comment">//边的数目</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token comment">//邻接表</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Digraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//初始化顶点数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span>        <span class="token comment">//初始化边的数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表中的空队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取顶点数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边的数目</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向有向图中添加一条边 v-&gt;w</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//由于有向图中边是有向的，v-&gt;w 边，只需要让w出现在v的邻接表中，而不需要让v出现在w的邻接表中</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//边的数目自增1</span>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取由v指出的边所连接的所有顶点</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">adj</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//该图的反向图</span>    <span class="token keyword">private</span> <span class="token class-name">Digraph</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//创建新的有向图对象</span>        <span class="token class-name">Digraph</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Digraph</span><span class="token punctuation">(</span><span class="token class-name">V</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历0~V-1所有顶点,拿到每一个顶点v</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>v<span class="token operator">&lt;</span><span class="token class-name">V</span><span class="token punctuation">;</span>v<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//得到原图中的v顶点对应的邻接表,原图中的边为 v-&gt;w,则反向图中边为w-&gt;v;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> w <span class="token operator">:</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                r<span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-2-拓扑排序"><a href="#9-2-拓扑排序" class="headerlink" title="9.2 拓扑排序"></a>9.2 拓扑排序</h5><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122112207858.png" alt="1"></p><p>​    给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明 确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122112140326.png" alt="拓扑排序"></p><h6 id="9-2-1检测有向图中的环"><a href="#9-2-1检测有向图中的环" class="headerlink" title="9.2.1检测有向图中的环"></a>9.2.1检测有向图中的环</h6><p>如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有 问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个 环：</p><p>因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。</p><p><strong>检测有向环实现</strong></p><p>在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：</p><ol><li>在如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；</li><li>如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；</li><li>如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；</li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectedCycle</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//记录图中是否有环</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> hasCycle<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> onStack<span class="token punctuation">;</span>    <span class="token comment">//创建一个检测环对象，检测图G中是否有环</span>    <span class="token keyword">public</span> <span class="token class-name">DirectedCycle</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的marked数组</span>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//创建一个和图的顶点数一样大小的onStack数组</span>        onStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//默认没有环</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hasCycle<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment">//遍历搜索图中的每一个顶点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点没有搜索过，则搜索</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//基于深度优先搜索，检测图G中是否有环</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//把当前顶点标记为已搜索</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//让当前顶点进栈</span>        onStack<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//遍历v顶点的邻接表，得到每一个顶点w</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//如果顶点w已经被搜索过，则查看顶点w是否在栈中，如果在，则证明图中有环，修改hasCycle标记，结束循环</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>onStack<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                hasCycle<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//当前顶点已经搜索完毕，让当前顶点出栈</span>        onStack<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断w顶点与s顶点是否相通</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> hasCycle<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-2-2基于深度优先的顶点排序"><a href="#9-2-2基于深度优先的顶点排序" class="headerlink" title="9.2.2基于深度优先的顶点排序"></a>9.2.2基于深度优先的顶点排序</h6><p>​    如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发 现其实深度优先搜索有一个特点，那就是在一个连通子图上，每个顶点只会被搜索一次，如果我们能在深度优先搜 索的基础上，添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。</p><p><strong>顶点排序实现</strong></p><p>​    在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该 顶点放入到reversePost中，这样就可以实现顶点排序。</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DepthFirstOrder</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点是否已经被搜索</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//使用栈，存储顶点序列</span>    <span class="token keyword">private</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> reversePost<span class="token punctuation">;</span>    <span class="token comment">//创建一个检测环对象，检测图G中是否有环</span>    <span class="token keyword">public</span> <span class="token class-name">DepthFirstOrder</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的marked数组</span>        marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        reversePost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历搜索图中的每一个顶点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点没有搜索过，则搜索</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//基于深度优先搜索，检测图G中是否有环</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//把当前顶点标记为已搜索</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//遍历v顶点的邻接表，得到每一个顶点w</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span> w <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前顶点w没有被搜索过，则递归搜索与w顶点相通的其他顶点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//当前顶点已经搜索完毕，让当前顶点入栈</span>        reversePost<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取顶点线性序列</span>    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">reversePost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> reversePost<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-2-3-拓扑排序实现"><a href="#9-2-3-拓扑排序实现" class="headerlink" title="9.2.3 拓扑排序实现"></a>9.2.3 拓扑排序实现</h6><p>​    前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环， 则调用顶点排序即可。</p><p>代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TopoLogical</span> <span class="token punctuation">{</span>    <span class="token comment">//顶点的拓扑排序</span>    <span class="token keyword">private</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> order<span class="token punctuation">;</span>    <span class="token comment">//构造拓扑排序对象</span>    <span class="token keyword">public</span> <span class="token class-name">TopoLogical</span><span class="token punctuation">(</span><span class="token class-name">Digraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建检测环对象，检测图G中是否有环</span>        <span class="token class-name">DirectedCycle</span> dCycle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DirectedCycle</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dCycle<span class="token punctuation">.</span><span class="token function">hasCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果没有环，创建顶点排序对象，进行顶点排序</span>            <span class="token class-name">DepthFirstOrder</span> depthFirstOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DepthFirstOrder</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            order <span class="token operator">=</span> depthFirstOrder<span class="token punctuation">.</span><span class="token function">reversePost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断图G是否有环</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isCycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> order<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取拓扑排序的所有顶点</span>    <span class="token keyword">public</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-3-加权无向图"><a href="#9-3-加权无向图" class="headerlink" title="9.3 加权无向图"></a>9.3 加权无向图</h5><p>​        加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图 中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成 本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞 才能使时间成本最低或者是金钱成本最低？</p><p>​    在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过那条路径到达4顶点最好 呢？此时就要考虑，那条路径的成本最低。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122153831330.png" alt="加权无向图"></p><h6 id="9-3-1-加权无向图边的表示"><a href="#9-3-1-加权无向图边的表示" class="headerlink" title="9.3.1 加权无向图边的表示"></a>9.3.1 加权无向图边的表示</h6><p>​    加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用 对象来描述一条边。</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment">//顶点一</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token comment">//顶点二</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span><span class="token comment">//当前边的权重</span>    <span class="token comment">//通过顶点v和w，以及权重weight值构造一个边对象</span>    <span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边的权重值</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边上的一个点</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边上除了顶点vertex外的另外一个顶点</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">other</span><span class="token punctuation">(</span><span class="token keyword">int</span> vertex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>vertex<span class="token operator">==</span>v<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果传入的顶点vertext是v，则返回另外一个顶点w</span>            <span class="token keyword">return</span> w<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment">//如果传入的顶点vertext不是v，则返回v即可</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> that<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cmp<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>that<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前边的权重大于参数边that的权重，返回1</span>            cmp<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>that<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前边的权重小于参数边that的权重，返回-1</span>            cmp<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment">//如果当前边的权重等于参数边that的权重，返回0</span>            cmp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> cmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-3-2-加权无向图的实现"><a href="#9-3-2-加权无向图的实现" class="headerlink" title="9.3.2 加权无向图的实现"></a>9.3.2 加权无向图的实现</h6><p>​    之前我们已经完成了无向图，在无向图的基础上，我们只需要把边的表示切换成Edge对象即可。</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeWeightedGraph</span> <span class="token punctuation">{</span>    <span class="token comment">//顶点总数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token comment">//边的总数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token comment">//邻接表</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span>    <span class="token comment">//创建一个含有V个顶点的空加权无向图</span>    <span class="token keyword">public</span> <span class="token class-name">EdgeWeightedGraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//初始化顶点数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span>        <span class="token comment">//初始化边的数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表中的空队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取图中顶点的数量</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取图中边的数量</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向加权无向图中添加一条边e</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取边中的一个顶点v</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取边中的另一个顶点w</span>        <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//因为是无向图，所以边e需要同时出现在两个顶点的邻接表中</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        adj<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//边的数量+1</span>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取和顶点v关联的所有边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">adj</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取加权无向图的所有边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个队列，存储所有的边</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> allEdge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历顶点，拿到每个顶点的邻接表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//遍历邻接表，拿到邻接表中的每条边</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> e <span class="token operator">:</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">/*                因为无向图中，每条边对象Edge都会在两个顶点的邻接表中各出现一次，为了不重复获取，暂定一条规则：                除了当前顶点v，再获取边e中的另外一个顶点w，如果v&lt;w则添加，这样可以保证同一条边只会被统计一次                */</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">&lt;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                allEdge<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> allEdge<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-4最小生成树"><a href="#9-4最小生成树" class="headerlink" title="9.4最小生成树"></a>9.4最小生成树</h5><p>​    之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才 能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。</p><h6 id="9-4-1-最小生成树定义及相关约定"><a href="#9-4-1-最小生成树定义及相关约定" class="headerlink" title="9.4.1 最小生成树定义及相关约定"></a>9.4.1 最小生成树定义及相关约定</h6><p>​    图的生成树是它的一棵含有其所有顶点的无环连通子图，一副加权无向图的最小生成树它的一棵权值(树中所有边 的权重之和)最小的生成树</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122154318214.png" alt="最小生成树"></p><p><strong>约定：</strong></p><p>​    只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图 的最小生成树，合并到一起称为最小生成森林。</p><p>​    所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算 法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。</p><h6 id="9-4-2-最小生成树原理"><a href="#9-4-2-最小生成树原理" class="headerlink" title="9.4.2 最小生成树原理"></a>9.4.2 最小生成树原理</h6><p><strong>树的性质</strong></p><ol><li>用一条边接树中的任意两个顶点都会产生一个新的环；</li><li>从树中删除任意一条边，将会得到两棵独立的树；</li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122154505326.png" alt="树的性质"></p><p> <strong>切分定理</strong></p><p>要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。</p><p><strong>切分：</strong></p><p>​    将图的所有顶点按照某些规则分为两个非空且没有交集的集合。</p><p><strong>横切边：</strong></p><p>​    连接两个属于不同集合的顶点的边称之为横切边。</p><p><strong>切分定理：</strong></p><p>​    在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122154626629.png" alt="切分定理"></p><p>**注意:**一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。</p><h6 id="9-4-3-贪心算法"><a href="#9-4-3-贪心算法" class="headerlink" title="9.4.3 贪心算法"></a>9.4.3 贪心算法</h6><p>​    贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，使用切分定理找到最小生成树的一条 边，不断的重复直到找到最小生成树的所有边。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小 生成树。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122154737733.png" alt="贪心算法"></p><p>​    计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在 于保存切分和判定权重最小的横切边的方式。</p><h5 id="9-5-最小生成树算法"><a href="#9-5-最小生成树算法" class="headerlink" title="9.5  最小生成树算法"></a>9.5  最小生成树算法</h5><h6 id="9-5-1Prim算法"><a href="#9-5-1Prim算法" class="headerlink" title="9.5.1Prim算法"></a>9.5.1Prim算法</h6><p>​    第一种计算最小生成树的方法叫Prim算法，它的每一步都会为一棵生成中的树添加一条边。一开始这棵树 只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点与不在树中的顶点且权重最小的边加 入到树中。</p><p><strong>Prim算法的切分规则：</strong></p><p>​    把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122154944880.png" alt="Prim算法的切分规则"></p><p><strong>Prim算法的实现原理</strong></p><p>​    Prim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作， 可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。</p><p>​    我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前 顶点的边权重。</p><p>​    初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接 表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表 示了。</p><p>​    现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重 最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也 成为了横切边，这时需要做两个操作：</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122155155521.png" alt="1"></p><ol><li><p>0-7这条边已经不是横切边了，需要让它失效：</p><p>只需要调用最小索引优先队列的delMin()方法即可完成；</p></li><li><p>2和4顶点各有两条连接指向最小生成树，需要只保留一条：</p><p>4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，<br>0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。</p></li></ol><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122155212521.png" alt="2"></p><p>我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中。</p><p><strong>代码</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimMST</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示当前顶点和最小生成树之间的最短边</span>    <span class="token keyword">private</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重</span>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> distTo<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> marked<span class="token punctuation">;</span>    <span class="token comment">//存放树中顶点与非树中顶点之间的有效横切边</span>    <span class="token keyword">private</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> pq<span class="token punctuation">;</span>    <span class="token comment">//根据一副加权无向图，创建最小生成树计算对象</span>    <span class="token keyword">public</span> <span class="token class-name">PrimMST</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的Edge数组，表示边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//创建一个和图的顶点数一样大小的double数组，表示权重，并且初始化数组中的内容为无穷大，无穷大即表示不存在这样的边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> distTo<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        distTo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>POSITIVE_INFINITY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//创建一个和图的顶点数一样大小的boolean数组，表示当前顶点是否已经在树中</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>marked <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//默认让顶点0进入树中，但0顶点目前没有与树中其他的顶点相连接，因此初始化distTo[0]=0.0</span>        distTo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token comment">//使用顶点0和权重0初始化pq</span>        pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历有效边队列</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//找到权重最小的横切边对应的顶点，加入到最小生成树中</span>            <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> pq<span class="token punctuation">.</span><span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//将顶点v添加到最小生成树中，并且更新数据</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//把顶点v添加到树中</span>        marked<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">//遍历顶点v的邻接表,得到每一条边Edge e,</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//边e的一个顶点是v，找到另外一个顶点w；</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//检测是否已经在树中，如果在，则继续下一次循环，如果不在，则需要修正当前顶点w距离最小生</span>            成树的最小边edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span>以及它的权重distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span>，还有有效横切边也需要修正            <span class="token keyword">if</span> <span class="token punctuation">(</span>marked<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>            <span class="token comment">//如果v-w边e的权重比目前distTo[w]权重小，则需要修正数据</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//把顶点w距离最小生成树的边修改为e</span>                edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment">//把顶点w距离最小生成树的边的权重修改为e.weight()</span>                distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//如果pq中存储的有效横切边已经包含了w顶点，则需要修正最小索引优先队列w索引关联的权</span>                重值                <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pq<span class="token punctuation">.</span><span class="token function">changeItem</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">//如果pq中存储的有效横切边不包含w顶点，则需要向最小索引优先队列中添加v-w和其</span>                    权重值                    pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取最小生成树的所有边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建队列</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历edgeTo数组，找到每一条边，添加到队列中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> marked<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edgeTo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            edges<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>edgeTo<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> edges<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrimTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">//创建输入流</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span>        <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">PrimTest</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>"min_create_tree_test        <span class="token punctuation">.</span>txt"<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取顶点数目，初始化EdgeWeightedGraph图</span>        <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EdgeWeightedGraph</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//读取边的数目</span>        <span class="token keyword">int</span> edgeNumber <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//循环读取每一条边，并调用addEdge方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> edgeNumber<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> line <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">double</span> weight <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> w<span class="token punctuation">,</span> weight<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//构建PrimMST对象</span>        <span class="token class-name">PrimMST</span> mst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrimMST</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取最小生成树的边</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> edges <span class="token operator">=</span> mst<span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//打印输出</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> edges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>edge<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-"</span> <span class="token operator">+</span> edge<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>edge<span class="token punctuation">.</span><span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"::"</span> <span class="token operator">+</span>                edge<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-5-2-kruskal算法"><a href="#9-5-2-kruskal算法" class="headerlink" title="9.5.2 kruskal算法"></a>9.5.2 kruskal算法</h6><p>​    kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它 们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。</p><p><strong>kruskal算法和prim算法的区别：</strong></p><p>​    Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候 也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副 加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林， kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122155607176.png" alt=" kruskal算法"></p><p>kruskal<strong>算法的实现原理</strong></p><p>​    在设计API的时候，使用了一个MinPriorityQueue pq存储图中所有的边，每次使用pq.delMin()取出权重最小的 边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶 点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会 形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树 合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所 有边。</p><p><strong>使用并查集的思想</strong></p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KruskalMST</span> <span class="token punctuation">{</span>    <span class="token comment">//保存最小生成树的所有边</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> mst<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以</span>    把顶点v所在的树和顶点w所在的树合并    <span class="token keyword">private</span> <span class="token class-name">UF_Tree_Weighted</span> uf<span class="token punctuation">;</span>    <span class="token comment">//存储图中所有的边，使用最小优先队列，对边按照权重进行排序</span>    <span class="token keyword">private</span> <span class="token class-name">MinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> pq<span class="token punctuation">;</span>    <span class="token comment">//根据一副加权无向图，创建最小生成树计算对象</span>    <span class="token keyword">public</span> <span class="token class-name">KruskalMST</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedGraph</span> <span class="token class-name">G</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//初始化mst队列</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mst <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//初始化并查集对象uf,容量和图的顶点数相同</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UF_Tree_Weighted</span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//初始化最小优先队列pq，容量比图的边的数量大1，并把图中所有的边放入pq中</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>E</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Edge</span> edge <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>edge<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果优先队列pq不为空，也就是还有边未处理，并且mst中的边还不到V-1条，继续遍历</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> mst<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//取出pq中权重最小的边e</span>            <span class="token class-name">Edge</span> e <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//获取边e的两个顶点v和w</span>            <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">either</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">other</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">/*            通过uf.connect(v,w)判断v和w是否已经连通，            如果连通:            则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵            树的任意两个顶点上添加一条边，都会形成环，            而最小生成树不能有环的存在;            如果不连通:            则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树,并把这条边加入            到mst队列中            */</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">connected</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        uf<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>            mst<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取最小生成树的所有边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">&gt;</span></span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> mst<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-6-加权有向图"><a href="#9-6-加权有向图" class="headerlink" title="9.6 加权有向图"></a>9.6 加权有向图</h5><p>之前学习的加权无向图中，边是没有方向的，并且同一条边会同时出现在该边的两个顶点的邻接表中，为了能够处 理含有方向性的图的问题，我们需要实现以下加权有向图。</p><h6 id="9-6-1-加权有向图的边的表示代码："><a href="#9-6-1-加权有向图的边的表示代码：" class="headerlink" title="9.6.1 加权有向图的边的表示代码："></a>9.6.1 <strong>加权有向图</strong>的<strong>边</strong>的表示代码：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DirectedEdge</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> v<span class="token punctuation">;</span><span class="token comment">//起点</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> w<span class="token punctuation">;</span><span class="token comment">//终点</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">double</span> weight<span class="token punctuation">;</span><span class="token comment">//当前边的权重</span>    <span class="token comment">//通过顶点v和w，以及权重weight值构造一个边对象</span>    <span class="token keyword">public</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">double</span> weight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>v <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取边的权重值</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> weight<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取有向边的起点</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取有向边的终点</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> w<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="9-6-2-加权有向图的实现"><a href="#9-6-2-加权有向图的实现" class="headerlink" title="9.6.2  加权有向图的实现"></a>9.6.2  加权有向图的实现</h6><p>之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。</p><p><strong>代码</strong>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EdgeWeightedDigraph</span> <span class="token punctuation">{</span>    <span class="token comment">//顶点总数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token comment">//边的总数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token comment">//邻接表</span>    <span class="token keyword">private</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> adj<span class="token punctuation">;</span>    <span class="token comment">//创建一个含有V个顶点的空加权有向图</span>    <span class="token keyword">public</span> <span class="token class-name">EdgeWeightedDigraph</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//初始化顶点数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span> <span class="token operator">=</span> <span class="token class-name">V</span><span class="token punctuation">;</span>        <span class="token comment">//初始化边的数量</span>        <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>E</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token punctuation">[</span><span class="token class-name">V</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//初始化邻接表中的空队列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> adj<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            adj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取图中顶点的数量</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">V</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">V</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取图中边的数量</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token class-name">E</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token class-name">E</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//向加权有向图中添加一条边e</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addEdge</span><span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//获取有向边的起点</span>        <span class="token keyword">int</span> v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//因为是有向图，所以边e只需要出现在起点v的邻接表中</span>        adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//边的数量+1</span>        <span class="token class-name">E</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取由顶点v指出的所有的边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span> <span class="token function">adj</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> adj<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取加权有向图的所有边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span> <span class="token function">edges</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建一个队列，存储所有的边</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span> allEdge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历顶点，拿到每个顶点的邻接表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> v <span class="token operator">&lt;</span> <span class="token class-name"><span class="token namespace">this<span class="token punctuation">.</span></span>V</span><span class="token punctuation">;</span> v<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//遍历邻接表，拿到邻接表中的每条边存储到队列中</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            allEdge<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> allEdge<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="9-7-最短路径"><a href="#9-7-最短路径" class="headerlink" title="9.7 最短路径"></a>9.7 最短路径</h5><p>​    有了加权有向图之后，我们立刻就能联想到实际生活中的使用场景，例如在一副地图中，找到顶点a与地点b之间的 路径，这条路径可以是距离最短，也可以是时间最短，也可以是费用最小等，如果我们把 距离/时间/费用 看做是 成本，那么就需要找到地点a和地点b之间成本最小的路径，也就是我们接下来要解决的最短路径问题。</p><h6 id="9-7-1-最短路径定义及性质"><a href="#9-7-1-最短路径定义及性质" class="headerlink" title="9.7.1 最短路径定义及性质"></a>9.7.1 最短路径定义及性质</h6><p><strong>定义：</strong> 在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。</p><p><strong><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122170615562.png" alt="最短路径"></strong></p><p><strong>性质：</strong></p><ol><li>路径具有方向性；</li><li>权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低</li><li>只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径， 为了简化问题，这里只考虑连通图。</li><li>.最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一 条即可。 最短路径树</li></ol><p><strong>最短路径树：</strong> </p><p>​    给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有 顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。</p><h6 id="9-7-2-松弛技术"><a href="#9-7-2-松弛技术" class="headerlink" title="9.7.2 松弛技术"></a>9.7.2 松弛技术</h6><p>​    松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还 有存在更短的路径，那么把皮筋转移到更短的路径上，皮筋就可以放松了。</p><p>​    松弛这种简单的原理刚好可以用来计算最短路径树。</p><p>​    在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们 只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]=0；顶 点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条 件更新edgeTo和distTo中的数据，最终就可以得到最短路劲树。</p><p><strong>边的松弛：</strong></p><ul><li>放松边v-&gt;w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？</li><li>如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]=表示v-&gt;w这条边的 DirectedEdge对象，distTo[w]=distTo[v]+v-&gt;w这条边的权重；</li><li>如果不是，则忽略v-&gt;w这条边。</li></ul><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122170837111.png" alt="边的松弛"></p><p><strong>顶点的松弛：</strong></p><p>​    顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶 点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。</p><p>​    如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0-&gt;2-&gt;7&gt;3-&gt;6的过程如下</p><p><img src="/2021/11/16/shu-ju-jie-gou-yu-suan-fa-shu-ju-jie-gou/image-20211122170924068.png" alt="顶点的松弛"></p><h6 id="9-7-3-Dijstra算法实现"><a href="#9-7-3-Dijstra算法实现" class="headerlink" title="9.7.3 Dijstra算法实现"></a>9.7.3 Dijstra算法实现</h6><p>​    Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边 是有效横切边pq队列中的权重最小的边。    </p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DijkstraSP</span> <span class="token punctuation">{</span>    <span class="token comment">//索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边</span>    <span class="token keyword">private</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">[</span><span class="token punctuation">]</span> edgeTo<span class="token punctuation">;</span>    <span class="token comment">//索引代表顶点，值从顶点s到当前顶点的最短路径的总权重</span>    <span class="token keyword">private</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token punctuation">]</span> distTo<span class="token punctuation">;</span>    <span class="token comment">//存放树中顶点与非树中顶点之间的有效横切边</span>    <span class="token keyword">private</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> pq<span class="token punctuation">;</span>    <span class="token comment">//根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象</span>    <span class="token keyword">public</span> <span class="token class-name">DijkstraSP</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedDigraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//创建一个和图的顶点数一样大小的DirectedEdge数组，表示边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>edgeTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DirectedEdge</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">//创建一个和图的顶点数一样大小的double数组，表示权重，并且初始化数组中的内容为无穷大，无穷大即表示不存在这样的边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>distTo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">double</span><span class="token punctuation">[</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> distTo<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        distTo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>POSITIVE_INFINITY<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//创建一个和图的顶点数一样大小的索引优先队列，存储有效横切边</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexMinPriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">G<span class="token punctuation">.</span>V</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//默认让顶点s进入树中，但s顶点目前没有与树中其他的顶点相连接，因此初始化distTo[s]=0.0</span>        distTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        <span class="token comment">//使用顶点s和权重0.0初始化pq</span>        pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//遍历有效边队列</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//松弛图G中的顶点</span>            <span class="token function">relax</span><span class="token punctuation">(</span><span class="token class-name">G</span><span class="token punctuation">,</span> pq<span class="token punctuation">.</span><span class="token function">delMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//松弛图G中的顶点v</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">relax</span><span class="token punctuation">(</span><span class="token class-name">EdgeWeightedDigraph</span> <span class="token class-name">G</span><span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//松弛顶点v就是松弛顶点v邻接表中的每一条边，遍历邻接表</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DirectedEdge</span> e <span class="token operator">:</span> <span class="token class-name">G</span><span class="token punctuation">.</span><span class="token function">adj</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//获取边e的终点</span>            <span class="token keyword">int</span> w <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token keyword">to</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//起点s到顶点w的权重是否大于起点s到顶点v的权重+边e的权重,如果大于，则修改s-&gt;w的路径：</span>            edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">,</span>并修改distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">weitht</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>如果不大于，则忽略            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">distTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token function">distTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                distTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">weight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                edgeTo<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>e<span class="token punctuation">;</span>                <span class="token comment">//如果顶点w已经存在于优先队列pq中，则重置顶点w的权重</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    pq<span class="token punctuation">.</span><span class="token function">changeItem</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token function">distTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token comment">//如果顶点w没有出现在优先队列pq中，则把顶点w及其权重加入到pq中</span>                    pq<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span><span class="token function">distTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//获取从顶点s到顶点v的最短路径的总权重</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">distTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断从顶点s到顶点v是否可达</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> distTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">.</span>POSITIVE_INFINITY<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//查询从起点s到顶点v的最短路径中所有的边</span>    <span class="token keyword">public</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span> <span class="token function">pathTo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//如果顶点s到v不可达，则返回null</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPathTo</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//创建队列Queue保存最短路径的边</span>        <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DirectedEdge</span><span class="token punctuation">&gt;</span></span> edges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//从顶点v开始，逆向寻找，一直找到顶点s为止，而起点s为最短路劲树的根结点，所以</span>        edgeTo<span class="token punctuation">[</span>s<span class="token punctuation">]</span><span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">DirectedEdge</span> e<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            e <span class="token operator">=</span> edgeTo<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            edges<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            v <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> edges<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/2021/11/15/dubbo/"/>
      <url>/2021/11/15/dubbo/</url>
      
        <content type="html"><![CDATA[<p>大型互联网架构目标：</p><p><img src="/2021/11/15/dubbo/image-20211115145230324.png" alt="架构目标（1）"></p><p><img src="/2021/11/15/dubbo/image-20211115145358776.png" alt="架构目标（2）"></p><p>集群与分布式：</p><ul><li>集群：很多服务器部署同一业务模块</li><li>分布式： 不同服务器部署不同业务模块，共同完成业务。</li><li>需求：高可用，高并发，可伸缩，高可扩展</li></ul><p>架构演进：</p><ul><li>单体架构：单机部署；简单；项目启动慢，可靠性差，可伸缩性差，扩展性和可维护性差，性能低。</li><li>垂直架构：将单体架构中的多个模块拆分为多个独立的项目。形成多个单独的单体架构；重复功能太多。</li><li>分布式架构：在哪垂直架构基础上，将公共业务模块抽取出来，作为独立的服务，供其他调用者消费，以实现服务的共享和重用；RPC远程过程调用；服务提供方一旦变更，所有消费者都需变更。</li><li>SOA架构（面向服务的架构）：是一个组件模型，它将应用程序的不同功能单元进行拆分，并通过这些服务之间定义良好的接口你和契约联系起来。</li><li>微服务架构：在SOA架构上做的升华，微服务架构强调的重点是”业务需要彻底的组件化和服务化“，原有的单个业务系统会拆分为多跟可以独立开发，设计，运行的小应用。这些小应用之间通过服务完成交互或集成。</li></ul><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo是SOA架构的产物，spring Cloud是微服务架构的产物</p><h5 id="Dubbo概述："><a href="#Dubbo概述：" class="headerlink" title="Dubbo概述："></a>Dubbo概述：</h5><p>Dubbo是一个阿里巴巴公司开源的一个高性能，轻量级的Java PRC框架，致力于提供高性能和透明化的RPC远程调用服务方案，以及SOA服务治理方案。</p><p>架构：</p><p><img src="/2021/11/15/dubbo/image-20211115152536951.png" alt="Dubbo架构"></p><p>流程：</p><ol><li>register：注册，服务提供者在注册中心注册</li><li>subscribe： 订阅,消费者在注册中心进行订阅</li><li>notify： 通知，注册中心对消费者进行通知</li><li>invoke： 调用，消费者对服务提供者进行调用</li><li>count：管理者进行记录</li></ol><h5 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h5><p>zookeeper:推荐使用的注册中心</p><ul><li>Liunx 安装zookeeper</li><li>修改配置文件</li><li>启动zookeeper</li></ul><p>dubbo-admin:</p><ul><li>dubbo-admin管理平台，是图形化的服务管理页面</li><li>从注册中心中获取所有的提供者/消费者进行配置管理</li><li>路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡等管理功能。</li><li>是一个前后端分离的项目，前端使用vue,后端使用spring boot</li><li>按照dubbo-admin其实就是部署该项目</li></ul><h5 id="dubbo高级特性"><a href="#dubbo高级特性" class="headerlink" title="dubbo高级特性"></a>dubbo高级特性</h5><ul><li>序列化</li><li>地址缓存</li><li>超时与重试<ul><li>dubbo设施超时时间，无法在时间段内完成服务，则自动断开连接</li><li>重试机制避免网络抖动</li></ul></li><li>多版本</li><li>负载均衡—-4种策略<ul><li>Random：按权重随机，默认值，按权重设置随机概率。</li><li>RoundRobin: 按权重轮询</li><li>LeastActive：最少活跃调用数，相同活跃数的随机</li><li>ConsistenHash： 一致性HAsh，相同参数的请求总是发送到同一调用者。</li></ul></li><li>集群容错模式<ul><li>Failover Cluster：失败重试。默认值。当出现失败，重试其他服务器，默认重试两次，使用retries配置。一般用于读操作</li><li>Failfast Cluster: 快速失败，出现异常时，直接忽略，返回一个空结果。</li><li>Failsafe Cluster:失败安全，出现异常时，直接忽略。返回一个空结果。</li><li>Failback Cluster: 失败自动恢复，后台记录失败请求，定时发送。</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回。</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。</li></ul></li><li>服务降级<ul><li>mock=force:return null  表示消费方对该服务的方法调用都直接返回null值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响</li><li>mock=fail:return null 表示消费方对该服务的方法调用在失败后，再返回null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Dubbo </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法--算法篇</title>
      <link href="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/"/>
      <url>/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h5 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h5><p>算法是值解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p><p><strong>算法的需求：</strong></p><ol><li>花最小的时间完成需求</li><li>占最小的内存空间完成需求</li></ol><p>研究算法的目的就是减少时间和空间的需求，分别涉及时间复杂度和空间复杂度</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h5 id="冒泡排序："><a href="#冒泡排序：" class="headerlink" title="冒泡排序："></a>冒泡排序：</h5><h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><ol><li>比较相邻的元素，如果前一个元素比后一个元素大，就交换这两个元素的位置</li><li>对每一对相邻元素做同样的工作，从开始第一对元素到结局的最后一对元素。最终最后位置的元素就是最大值</li></ol><h6 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bubble</span> <span class="token punctuation">{</span>    <span class="token comment">/*    *排序     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>a<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">greater</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     *比较V元素是否大于W元素     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">greater</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> v<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     *交换数组中元素i和j的值     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Comparable</span> temp<span class="token punctuation">;</span>        temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：O(N²)</li></ul><h5 id="选择排序："><a href="#选择排序：" class="headerlink" title="选择排序："></a>选择排序：</h5><h6 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h6><ol><li>在每次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引的值大于其他索引的值，则假定其他索引的值为最小值，最后可以找到最小值所在的索引</li><li>交换第一个索引和最小处所在的索引</li></ol><h6 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">greater</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                min <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>i<span class="token punctuation">,</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：O(N²)</li></ul><h5 id="插入排序："><a href="#插入排序：" class="headerlink" title="插入排序："></a>插入排序：</h5><h6 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h6><ol><li> 将所有的元素分为两组，已排序的和未排序的；</li><li>找到未排序组中的第一个元素，向已经排序的组中进行插入</li><li>倒叙遍历已排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于待插入元素，那么就把这个待插入元素放在这个位置，其他的元素向后移动一位；</li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211116102200266.png" alt="插入排序"></p><h6 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">greater</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：O(N²)</li></ul><h5 id="希尔排序："><a href="#希尔排序：" class="headerlink" title="希尔排序："></a>希尔排序：</h5><h6 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h6><ol><li><p>选择一个增长量h，按照增长量h作为数据分组的依据对数据进行分组</p></li><li><p>对分好的组进行插入排序</p></li><li><p>减小增长量，最小减为1，重复第二步操作</p></li><li><p>增长量h的确定：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">&lt;</span>数组的长度<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    h<span class="token operator">=</span><span class="token number">2</span>h<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>h的减小规则：    h<span class="token operator">=</span>h<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211116103524141.png" alt="希尔排序"></p><h6 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//确定h的值</span>       <span class="token keyword">int</span> h<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>h<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           h<span class="token operator">=</span><span class="token number">2</span><span class="token operator">*</span>h<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>h<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment">//排序</span>           <span class="token comment">//找到待插入元素</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>h<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token comment">//按照分组插入排序</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">&gt;=</span>h<span class="token punctuation">;</span>j<span class="token operator">=</span>j<span class="token operator">-</span>h<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">greater</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token operator">-</span>h<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                       <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>j<span class="token operator">-</span>h<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                       <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           h<span class="token operator">=</span>h<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析：-3"><a href="#复杂度分析：-3" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：综合较快</li></ul><h5 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a>归并排序：</h5><h6 id="原理：-4"><a href="#原理：-4" class="headerlink" title="原理："></a>原理：</h6><ol><li>尽可能的将一组数据拆分为两个元素相等的子组，并对每个子组继续拆分，直到拆分的每个子组的元素个数是一为止。</li><li>将相邻的两个子组进行合并成一个有序的大组；</li><li>不断的重复第二步，直到最终只有一个组为止。</li><li><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211116152917635.png" alt="归并排序"></li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211116152819452.png" alt="归并排序（2）"></p><h6 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> assist<span class="token punctuation">;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//1.初始化辅助数组aais；</span>       assist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">[</span>a<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//2.定义一个lo和hi变量分别记录数组中最小的索引和最大的索引</span>       <span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> hi <span class="token operator">=</span> a<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*   对数组a从索引lo到hi之间的元素进行排序    */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//安全性校验</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//对lo到hi之间的数据进行分组，分为两组</span>       <span class="token keyword">int</span> mid <span class="token operator">=</span> lo <span class="token operator">+</span> <span class="token punctuation">(</span>hi <span class="token operator">-</span> lo<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">//中间索引</span>       <span class="token comment">//分别对两组开始排序</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//将两个组的数据进行归并</span>       <span class="token function">merge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*   对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并排序    */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//1.定义三个指针</span>       <span class="token keyword">int</span> i <span class="token operator">=</span> lo<span class="token punctuation">;</span>       <span class="token keyword">int</span> p1 <span class="token operator">=</span> lo<span class="token punctuation">;</span>       <span class="token keyword">int</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//2.遍历，移动p1指针和p2指针，比较索引处的值，小的放在辅助数组中。</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> hi<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">,</span>a<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>               assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token comment">//一侧指针遍历完毕，顺序遍历另一个指针，把数据放在辅助数组中</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>p1<span class="token operator">==</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">while</span> <span class="token punctuation">(</span>p2<span class="token operator">&lt;=</span>hi<span class="token punctuation">)</span><span class="token punctuation">{</span>              assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>p1<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">{</span>               assist<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token comment">//4.将辅助数组中的元素拷贝到原数组中</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> lo<span class="token punctuation">;</span>index<span class="token operator">&lt;=</span>hi<span class="token punctuation">;</span>index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> assist<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token comment">/*    *比较V元素是否大于W元素    */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> v<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析：-4"><a href="#复杂度分析：-4" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：O(n * log n)</li><li>空间复杂度：额外的内存开销；空间换时间</li></ul><h5 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h5><h6 id="原理：-5"><a href="#原理：-5" class="headerlink" title="原理："></a>原理：</h6><ol><li>首先设定一个分界值，通过分界值将数组分为左右两个部分；</li><li>将大于或等于边界值的数据放在数组右边，小于边界值的放在数组左边，此时左边各元素都小于等于分界值，而右边各元素都大于或等于分界值；</li><li>然后左边和右边的数据可以独立排序，过程为一二步</li><li>通过递归分别重复这些步骤</li></ol><h6 id="实现：-4"><a href="#实现：-4" class="headerlink" title="实现："></a>实现：</h6><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span>  <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span> lo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> hi <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>lo<span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*  对数组a从索引lo到hi之间的元素进行排序   */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> lo<span class="token punctuation">,</span> <span class="token keyword">int</span> hi<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//安全性校验</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>hi <span class="token operator">&lt;=</span> lo<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//需要对数组中的lo索引到hi索引的元素进行分组</span>       <span class="token keyword">int</span> partition <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> lo<span class="token punctuation">,</span> hi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回分界值位置变化后的索引</span>       <span class="token comment">//让左子组有序</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>lo<span class="token punctuation">,</span>partition<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//让右子组有序</span>       <span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>partition<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>hi<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*   对数组中从索引lo到hi的元素进行分组，并返回中间索引    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> lo<span class="token punctuation">,</span><span class="token keyword">int</span> hi<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//确定分界值</span>       <span class="token class-name">Comparable</span> key <span class="token operator">=</span> a<span class="token punctuation">[</span>lo<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">//定义两个指针，分别指向带切分元素的最小索引和最大索引处的下一个位置</span>       <span class="token keyword">int</span> left <span class="token operator">=</span>lo<span class="token punctuation">;</span>       <span class="token keyword">int</span> right <span class="token operator">=</span> hi<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">//切分</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token comment">//由右往左扫描，找到一个比中介值小的</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token operator">--</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">==</span>lo<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           <span class="token comment">//由左往右，找到一个大的</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">less</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>a<span class="token punctuation">[</span><span class="token operator">++</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token operator">==</span>hi<span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token operator">&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>               <span class="token keyword">break</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token comment">//判断指针左指针是否比右边指针小</span>       <span class="token punctuation">}</span>       <span class="token comment">//交换分界值</span>       <span class="token function">exch</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>lo<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> right<span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*    *比较V元素是否大于W元素    */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">less</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span> v<span class="token punctuation">,</span> <span class="token class-name">Comparable</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> v<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token comment">/*    *交换数组中元素i和j的值    */</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exch</span><span class="token punctuation">(</span><span class="token class-name">Comparable</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token class-name">Comparable</span> temp<span class="token punctuation">;</span>       temp <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="复杂度分析：-5"><a href="#复杂度分析：-5" class="headerlink" title="复杂度分析："></a>复杂度分析：</h6><ul><li>时间复杂度：<ul><li>最优情况：O(n*log n)</li><li>最坏情况：O(n²)</li><li>平均情况：O(n*log n)</li></ul></li></ul><h4 id="排序稳定性分析："><a href="#排序稳定性分析：" class="headerlink" title="排序稳定性分析："></a>排序稳定性分析：</h4><h6 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h6><p>​    数组中有若干元素，其中A元素与B元素相等，并且A元素在B元素前面，如果使用某种排序算法后，能够保证A元素依旧在B元素的前面，可以说这个算法是稳定的。</p><h6 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h6><p>​    多次排序的情况下，可以保持之前排序的原有意义，可以减少系统开销。</p><h6 id="常见排序算法的稳定性："><a href="#常见排序算法的稳定性：" class="headerlink" title="常见排序算法的稳定性："></a>常见排序算法的稳定性：</h6><ul><li>冒泡排序：稳定的</li><li>选择排序：不稳定的</li><li>插入排序：稳定的</li><li>希尔排序：不稳定的</li><li>归并排序： 稳定的</li><li>快速排序：不稳定的</li></ul><h3 id="常见算法："><a href="#常见算法：" class="headerlink" title="常见算法："></a>常见算法：</h3><h4 id="1-链表的应用"><a href="#1-链表的应用" class="headerlink" title="1.链表的应用"></a>1.链表的应用</h4><h5 id="1-1链表反转"><a href="#1-1链表反转" class="headerlink" title="1.1链表反转"></a>1.1链表反转</h5><p>单链表的反转，</p><p>需求： </p><p>原链表中数据为：1-&gt;2-&gt;3&gt;4</p><p> 反转后链表中数据为：4-&gt;3-&gt;2-&gt;1</p><p><strong>思路：</strong>    使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点， 直到把最后一个结点反转完毕，整个链表就反转完毕。</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117103431736.png" alt="链表反转"></p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">N</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//当前是空链表，不需要反转</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">reverse</span><span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/**** @param curr 当前遍历的结点* @return 反转后当前结点上一个结点*/</span><span class="token keyword">public</span> <span class="token class-name">Node</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token class-name">Node</span> curr<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//已经到了最后一个元素</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>curr<span class="token punctuation">.</span>next<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//反转后，头结点应该指向原链表中的最后一个元素</span>    head<span class="token punctuation">.</span>next<span class="token operator">=</span>curr<span class="token punctuation">;</span>    <span class="token keyword">return</span> curr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//递归调用反转当前节点的下一个节点，返回值是当前结点的上一个结点</span>    <span class="token class-name">Node</span> pre <span class="token operator">=</span> <span class="token function">reverse</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>    <span class="token comment">//当前结点的下一个结点设为null</span>    curr<span class="token punctuation">.</span>next<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//返回当前结点</span>    <span class="token keyword">return</span> curr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-2-快慢指针"><a href="#1-2-快慢指针" class="headerlink" title="1.2.快慢指针"></a>1.2.快慢指针</h5><p>​    快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以让 我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍</p><h6 id="1-2-1中间值问题"><a href="#1-2-1中间值问题" class="headerlink" title="1.2.1中间值问题"></a>1.2.1中间值问题</h6><p>需求代码:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"bb"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> third <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"cc"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fourth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"dd"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fifth <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"ee"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> six <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"ff"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> seven <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token string">"gg"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//完成结点之间的指向</span>    first<span class="token punctuation">.</span>next <span class="token operator">=</span> second<span class="token punctuation">;</span>    second<span class="token punctuation">.</span>next <span class="token operator">=</span> third<span class="token punctuation">;</span>    third<span class="token punctuation">.</span>next <span class="token operator">=</span> fourth<span class="token punctuation">;</span>    fourth<span class="token punctuation">.</span>next <span class="token operator">=</span> fifth<span class="token punctuation">;</span>    fifth<span class="token punctuation">.</span>next <span class="token operator">=</span> six<span class="token punctuation">;</span>    six<span class="token punctuation">.</span>next <span class="token operator">=</span> seven<span class="token punctuation">;</span>    <span class="token comment">//查找中间值</span>    <span class="token class-name">String</span> mid <span class="token operator">=</span> <span class="token function">getMid</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中间值为："</span><span class="token operator">+</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**    * @param first 链表的首结点    * @return 链表的中间结点的值    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getMid</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//结点类</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token comment">//存储数据</span>    <span class="token class-name">T</span> item<span class="token punctuation">;</span>    <span class="token comment">//下一个结点</span>    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">T</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>需求：</strong>请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。 利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以 此来达到找到中间节点的目的。</p><p><strong>思路：</strong>    如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117104523953.png" alt="中间值问题"></p><p>解决代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** @param first 链表的首结点* @return 链表的中间结点的值*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getMid</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slow <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fast <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        fast<span class="token operator">=</span>fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> slow<span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="1-2-2-单向链表有环问题"><a href="#1-2-2-单向链表有环问题" class="headerlink" title="1.2.2 单向链表有环问题"></a>1.2.2 单向链表有环问题</h6><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117105313780.png" alt="有环问题"></p><p><strong>需求</strong>： 请完善测试类Test中的isCircle方法，返回链表中是否有环。 </p><p><strong>解题思路：</strong>使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道 中，两个有速度 差，那么迟早两个人会相遇，只要相遇那么就说明有环。</p><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*** 判断链表中是否有环* @param first 链表首结点* @return ture为有环，false为无环*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isCircle</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slow <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fast <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="1-2-3有环链表入口问题"><a href="#1-2-3有环链表入口问题" class="headerlink" title="1.2.3有环链表入口问题"></a>1.2.3有环链表入口问题</h6><p><strong>需求</strong>： 请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。</p><p><strong>实现思路</strong> 当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为1，则慢指针与“新”指针相遇的地方就是环的入口。</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117110831633.png" alt="有环链表入口问题"></p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117111317555.png" alt="原理"></p><p>代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">getEntrance</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slow <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> fast <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> temp <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>fast<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>slow<span class="token operator">=</span>slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>slow<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-3约瑟夫问题"><a href="#1-3约瑟夫问题" class="headerlink" title="1.3约瑟夫问题"></a>1.3约瑟夫问题</h5><p><strong>问题描述：</strong> </p><p>传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决 定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往 后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡 为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与 第31个位置，从而逃过了这场死亡游戏 。</p><p> <strong>问题转换：</strong> </p><p>41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。</p><p> 1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；</p><p> 2.自退出那个人开始的下一个人再次从1开始报数，以此类推；</p><p> 3.求出最后退出的那个人的编号。</p><p> <strong>图示：</strong></p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117134516198.png" alt="约瑟夫问题"></p><p><strong>解题思路：</strong></p><ol><li>构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；</li><li>使用计数器count，记录当前报数的值； </li><li>遍历链表，每循环一次，count++； </li><li>判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；</li></ol><p><strong>代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token comment">//1.构建循环链表</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> first <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token comment">//记录前一个结点</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">41</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//第一个元素</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pre <span class="token operator">=</span> first<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    pre <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//构建循环链表，让最后一个结点指向第一个结点</span>        pre<span class="token punctuation">.</span>next<span class="token operator">=</span>first<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">//2.使用count，记录当前的报数值</span>    <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">//3.遍历链表，每循环一次，count++</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> n <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> before <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">!=</span>n<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0；</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">//删除当前结点</span>            before<span class="token punctuation">.</span>next <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>item<span class="token operator">+</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>before<span class="token operator">=</span>n<span class="token punctuation">;</span>n <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">/*打印剩余的最后那个人*/</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-栈的应用"><a href="#2-栈的应用" class="headerlink" title="2.栈的应用"></a>2.栈的应用</h4><h5 id="2-1-括号匹配问题"><a href="#2-1-括号匹配问题" class="headerlink" title="2.1 括号匹配问题"></a>2.1 括号匹配问题</h5><p>给定一个字符串，里边可能包含”()”小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。</p><ul><li> 例如： “(上海)(长安)”：正确匹配 </li><li>“上海((长安))”：正确匹配 “</li><li>上海(长安(北京)(深圳)南京)”:正确匹配</li><li> “上海(长安))”：错误匹配</li><li> “((上海)长安”：错误匹配</li></ul><p><strong>示例代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BracketsMatch</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"(上海(长安)())"</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> match <span class="token operator">=</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token string">"中的括号是否匹配："</span><span class="token operator">+</span>match<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>        <span class="token comment">/**        * 判断str中的括号是否匹配        * @param str 括号组成的字符串        * @return 如果匹配，返回true，如果不匹配，返回false        */</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>思路分析：</strong></p><ol><li><p>创建一个栈用来存储左括号 </p></li><li><p>从左往右遍历字符串，拿到每一个字符 </p></li><li><p>判断该字符是不是左括号，如果是，放入栈中存储 </p></li><li><p>判断该字符是不是右括号，如果不是，继续下一次循环 </p></li><li><p>如果该字符是右括号，则从栈中弹出一个元素t；</p></li><li><p>判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号 </p></li><li><p>循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配</p></li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117195542461.png" alt="流程图"></p><p><strong>代码解决：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BracketsMatch</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">"(fdafds(fafds)())"</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> match <span class="token operator">=</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token string">"中的括号是否匹配："</span> <span class="token operator">+</span> match<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 判断str中的括号是否匹配     *     * @param str 括号组成的字符串     * @return 如果匹配，返回true，如果不匹配，返回false     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isMatch</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建一个栈用来存储左括号</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> chars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.从左往右遍历字符串，拿到每一个字符</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> currChar <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>             <span class="token comment">//3.判断该字符是不是左括号，如果是，放入栈中存储</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>currChar<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                chars<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>currChar<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>currChar<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//4.判断该字符是不是右括号，如果不是，继续下一次循环</span>                <span class="token comment">//5.如果该字符是右括号，则从栈中弹出一个元素t；</span>                <span class="token class-name">String</span> t <span class="token operator">=</span> chars<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment">//7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-2-逆波兰表达式求值问题"><a href="#2-2-逆波兰表达式求值问题" class="headerlink" title="2.2 逆波兰表达式求值问题"></a>2.2 逆波兰表达式求值问题</h5><p><strong>中缀表达式：</strong> </p><p>​    中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总 是置于两个操作数中间。 </p><p>​    中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的 运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做 大量的优先级相关操作。</p><p> **逆波兰表达式(后缀表达式)**： </p><p>​    逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表 达式的特点：运算符总是放在跟它相关的操作数之后。</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117195949135.png" alt="逆波兰表达式"></p><p><strong>需求：</strong></p><p>​    给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。    </p><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReversePolishNotation</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//中缀表达式3*（17-15）+18/6的逆波兰表达式如下</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> notation <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"17"</span><span class="token punctuation">,</span> <span class="token string">"15"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span><span class="token string">"18"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">,</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token string">"+"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">caculate</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"逆波兰表达式的结果为："</span><span class="token operator">+</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**    * @param notaion 逆波兰表达式的数组表示方式    * @return 逆波兰表达式的计算结果    */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">caculate</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> notaion<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分析：</strong></p><ol><li><p>创建一个栈对象oprands存储操作数 </p></li><li><p>从左往右遍历逆波兰表达式，得到每一个字符串 </p></li><li><p>判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中 </p></li><li><p>如果是运算符，则从oprands栈中弹出两个操作数o1,o2 </p></li><li><p>使用该运算符计算o1和o2，得到结果result </p></li><li><p>把该结果压入oprands栈中 </p></li><li><p>遍历结束后，拿出栈中最终的结果返回</p></li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117200215320.png" alt="逆波兰表达式流程图"></p><p><strong>解决代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReversePolishNotation</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//中缀表达式3*（17-15）+18/6的逆波兰表达式如下</span>        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> notation <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"17"</span><span class="token punctuation">,</span> <span class="token string">"15"</span><span class="token punctuation">,</span> <span class="token string">"-"</span><span class="token punctuation">,</span> <span class="token string">"*"</span><span class="token punctuation">,</span> <span class="token string">"18"</span><span class="token punctuation">,</span> <span class="token string">"6"</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token string">"+"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">caculate</span><span class="token punctuation">(</span>notation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"逆波兰表达式的结果为："</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * @param notaion 逆波兰表达式的数组表示方式     * @return 逆波兰表达式的计算结果     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">caculate</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> notaion<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//1.创建一个栈对象oprands存储操作数</span>        <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> oprands <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.从左往右遍历逆波兰表达式，得到每一个字符串</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> notaion<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> curr <span class="token operator">=</span> notaion<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">//3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中</span>            <span class="token class-name">Integer</span> o1<span class="token punctuation">;</span>            <span class="token class-name">Integer</span> o2<span class="token punctuation">;</span>            <span class="token class-name">Integer</span> result<span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"+"</span><span class="token operator">:</span>            <span class="token comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span>                    o1 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    o2 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">//5.使用该运算符计算o1和o2，得到结果result</span>                    result <span class="token operator">=</span> o2 <span class="token operator">+</span> o1<span class="token punctuation">;</span>             <span class="token comment">//6.把该结果压入oprands栈中</span>                    oprands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"-"</span><span class="token operator">:</span>            <span class="token comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span>                    o1 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    o2 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//5.使用该运算符计算o1和o2，得到结果result</span>                    result <span class="token operator">=</span> o2 <span class="token operator">-</span> o1<span class="token punctuation">;</span>            <span class="token comment">//6.把该结果压入oprands栈中</span>                    oprands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"*"</span><span class="token operator">:</span>            <span class="token comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span>                    o1 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    o2 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5.使用该运算符计算o1和o2，得到结果result</span>                    result <span class="token operator">=</span> o2 <span class="token operator">*</span> o1<span class="token punctuation">;</span>            <span class="token comment">//6.把该结果压入oprands栈中</span>                    oprands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">case</span> <span class="token string">"/"</span><span class="token operator">:</span>                <span class="token comment">//4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2</span>                    o1 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    o2 <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//5.使用该运算符计算o1和o2，得到结果result</span>                    result <span class="token operator">=</span> o2 <span class="token operator">/</span> o1<span class="token punctuation">;</span>            <span class="token comment">//6.把该结果压入oprands栈中</span>                    oprands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    oprands<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>            <span class="token comment">//7.遍历结束后，拿出栈中最终的结果返回</span>        <span class="token class-name">Integer</span> result <span class="token operator">=</span> oprands<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h6><p>中缀表达式转换后缀表达式：</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211117232213113.png" alt="中->后"></p><h4 id="3-树"><a href="#3-树" class="headerlink" title="3.树"></a>3.树</h4><h5 id="3-1-二叉树的最大深度问题"><a href="#3-1-二叉树的最大深度问题" class="headerlink" title="3.1 二叉树的最大深度问题"></a>3.1 二叉树的最大深度问题</h5><p><strong>需求：</strong> 给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）;</p><p><strong>实现步骤：</strong> </p><ol><li><p>如果根结点为空，则最大深度为0； </p></li><li><p>计算左子树的最大深度； </p></li><li><p>计算右子树的最大深度；</p></li><li><p>当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token comment">//计算整个树的最大深度</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//计算指定树x的最大深度</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span><span class="token class-name">Node</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//1.如果根结点为空，则最大深度为0；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//2.计算左子树的最大深度；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxL <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//3.计算右子树的最大深度；</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxR <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1</span>        max <span class="token operator">=</span> maxL <span class="token operator">&gt;</span> maxR <span class="token operator">?</span> maxL <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> maxR <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-2-折纸问题"><a href="#3-2-折纸问题" class="headerlink" title="3.2 折纸问题"></a>3.2 折纸问题</h5><p><strong>需求：</strong> 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时 折痕是凹下去的，即折 痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2 次，压出折痕后展开，此时有三条折痕，从上 到下依次是下折痕、下折痕和上折痕。 </p><p>​    给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打 印： down；N=2时，打印： down down up</p><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211118191321707.png" alt="折纸问题"></p><p><strong>分析：</strong> 我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折 痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构 来描述对折后产生的折痕。 </p><p>这棵树有这样的特点： </p><ol><li><p>根结点为下折痕； </p></li><li><p>每一个结点的左子结点为下折痕；</p></li><li><p>每一个结点的右子结点为上折痕；</p></li></ol><p><img src="/2021/11/15/shu-ju-jie-gou-yu-suan-fa-suan-fa-pian/image-20211118191423281.png" alt="折纸树"></p><p><strong>实现步骤：</strong> </p><ol><li><p>定义结点类 </p></li><li><p>构建深度为N的折痕树； </p></li><li><p>使用中序遍历，打印出树中所有结点的内容； </p></li></ol><p>构建深度为N的折痕树： </p><ol><li><p>第一次对折，只有一条折痕，创建根结点；</p></li><li><p>如果不是第一次对折，则使用队列保存根结点； </p></li><li><p>循环遍历队列： </p><p>3.1 从队列中拿出一个结点； </p><p>3.2 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中； </p><p>3.3 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中； </p><p>3.4 判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一 个值为up的右子结点。</p></li></ol><p>代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PaperFolding</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//构建折痕树</span>        <span class="token class-name">Node</span> tree <span class="token operator">=</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//遍历折痕树，并打印</span>        <span class="token function">printTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//3.使用中序遍历，打印出树中所有结点的内容；</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printTree</span><span class="token punctuation">(</span><span class="token class-name">Node</span> tree<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tree <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>item <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//2.构建深度为N的折痕树；</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Node</span> <span class="token function">createTree</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token class-name">N</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Node</span> root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//1.第一次对折，只有一条折痕，创建根结点；</span>                root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//2.如果不是第一次对折，则使用队列保存根结点；</span>                <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Node</span><span class="token punctuation">&gt;</span></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//3.循环遍历队列：</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//3.1从队列中拿出一个结点；</span>                    <span class="token class-name">Node</span> tmp <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>            <span class="token comment">//3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        queue<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>            <span class="token comment">//3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一个值为up的右子结点。</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> tmp<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        tmp<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"down"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        tmp<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token string">"up"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//1.定义结点类</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>        <span class="token comment">//存储结点元素</span>        <span class="token class-name">String</span> item<span class="token punctuation">;</span>        <span class="token comment">//左子结点</span>        <span class="token class-name">Node</span> left<span class="token punctuation">;</span>        <span class="token comment">//右子结点</span>        <span class="token class-name">Node</span> right<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">String</span> item<span class="token punctuation">,</span> <span class="token class-name">Node</span> left<span class="token punctuation">,</span> <span class="token class-name">Node</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有点想说的话</title>
      <link href="/2021/11/12/you-dian-xiang-shuo-de-hua/"/>
      <url>/2021/11/12/you-dian-xiang-shuo-de-hua/</url>
      
        <content type="html"><![CDATA[<ul><li></li><li>想去某个地方大概是因为某个人吧</li><li>不知道是不是喜欢她，也许也不知道喜欢是什么</li><li>理想很难，我喜欢白日做梦</li><li>也许知道，也许不知道</li><li>怪话大全</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> no </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="/2021/11/06/wei-fu-wu/"/>
      <url>/2021/11/06/wei-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h3 id="初识微服务"><a href="#初识微服务" class="headerlink" title="初识微服务"></a>初识微服务</h3><h5 id="服务架构演变："><a href="#服务架构演变：" class="headerlink" title="服务架构演变："></a>服务架构演变：</h5><p>单体架构:</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107154730271.png" alt="单体架构"></p><p>分布式架构：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107154920043.png" alt="分布式架构"></p><p>微服务：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107155758199.png" alt="微服务"></p><h5 id="微服务技术栈"><a href="#微服务技术栈" class="headerlink" title="微服务技术栈"></a>微服务技术栈</h5><p><img src="/2021/11/06/wei-fu-wu/image-20211107152403489.png" alt="技术栈"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211107152434582.png" alt="持续集成"></p><h5 id="微服务技术对比："><a href="#微服务技术对比：" class="headerlink" title="微服务技术对比："></a>微服务技术对比：</h5><p><img src="/2021/11/06/wei-fu-wu/image-20211107160543855.png" alt="微服务技术对比"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211107160937260.png" alt="企业需求"></p><h5 id="SpringCloud："><a href="#SpringCloud：" class="headerlink" title="SpringCloud："></a>SpringCloud：</h5><p><img src="/2021/11/06/wei-fu-wu/image-20211107161117040.png" alt="springCloud"></p><h3 id="微服务入门"><a href="#微服务入门" class="headerlink" title="微服务入门"></a>微服务入门</h3><h5 id="服务拆分及远程调用："><a href="#服务拆分及远程调用：" class="headerlink" title="服务拆分及远程调用："></a>服务拆分及远程调用：</h5><p>服务拆分及注意事项：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107161609179.png" alt="服务拆分及注意事项"></p><p>服务远程调用：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107162443719.png" alt="注册RestTemplate"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211107163004978.png" alt="调用RestTemplate"></p><ul><li>注入Bean</li><li>调用RestTemplate发送HTTP请求</li></ul><h4 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h4><p>提供者与消费者：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107163401616.png" alt="提供者与消费者"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211107163423188.png" alt="服务调用关系"></p><p>eureka作用：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107164414677.png" alt="eureka作用"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211107164431833.png" alt="总结"></p><p>实现：</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107174113731.png" alt="实现"></p><h5 id="Ribbon负载均衡"><a href="#Ribbon负载均衡" class="headerlink" title="Ribbon负载均衡"></a>Ribbon负载均衡</h5><p>流程</p><p><img src="/2021/11/06/wei-fu-wu/image-20211107174407996.png" alt="流程"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211108150116452.png" alt="策略"></p><p><img src="/2021/11/06/wei-fu-wu/image-20211108150200691.png" alt="饥饿加载"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 微服务 </tag>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2021/10/31/io-liu/"/>
      <url>/2021/10/31/io-liu/</url>
      
        <content type="html"><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><h5 id="file类的概述和构造方法"><a href="#file类的概述和构造方法" class="headerlink" title="file类的概述和构造方法"></a>file类的概述和构造方法</h5><p>file：它是文件和目录路径名的抽象表示</p><ul><li><img src="/2021/10/31/io-liu/image-20211031091031778.png" alt="file"></li><li><img src="/2021/10/31/io-liu/image-20211031091058524.png" alt="构造方法"></li></ul><ul><li>```java<br>File f1 = new File(“O:\_post\IO流.md”);<pre><code>    File f2 = new File("O:_post", "IO流.md");    File f3 = new File("O:\\_post");    File f4 = new File(f3,"IO流.md");</code></pre><pre class="line-numbers language-none"><code class="language-none">##### File类创建功能![创建功能](IO流/image-20211031092133039.png)```javaFile f1 = new File("O:\\Blogger\\source\\_post\\IO流.md");        boolean b = f1.createNewFile(); File f3 = new File("O:\\Blogger\\source\\_post");        boolean b1 = f3.mkdir();        boolean b2 = f3.mkdirs();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="File类判断和获取功能"><a href="#File类判断和获取功能" class="headerlink" title="File类判断和获取功能"></a>File类判断和获取功能</h5><p><img src="/2021/10/31/io-liu/image-20211031092812307.png" alt="判断和获取功能"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">File</span> f3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"O:\\Blogger\\source\\_post"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Boolean</span> b3 <span class="token operator">=</span> f3<span class="token punctuation">.</span><span class="token function">isFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="File类删除功能"><a href="#File类删除功能" class="headerlink" title="File类删除功能"></a>File类删除功能</h5><p><img src="/2021/10/31/io-liu/image-20211031093534187.png" alt="删除功能"></p><p>绝对路径和相对路径吧的区别</p><p><img src="/2021/10/31/io-liu/image-20211031094025622.png" alt="绝对路径和相对路径"></p><p>删除目录的注意事项</p><p><img src="/2021/10/31/io-liu/image-20211031094420480.png" alt="注意事项"></p><p>遍历目录删除</p><p><img src="/2021/10/31/io-liu/image-20211031095740210.png" alt="需求分析"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"E:\\io"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">getAllFilePath</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getAllFilePath</span><span class="token punctuation">(</span><span class="token class-name">File</span> file<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">File</span><span class="token punctuation">[</span><span class="token punctuation">]</span> files <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">listFiles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>files <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">File</span> file1 <span class="token operator">:</span> files<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>file1<span class="token punctuation">.</span><span class="token function">isDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">getAllFilePath</span><span class="token punctuation">(</span>file1<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>file1<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><h5 id="IO流概述和分类"><a href="#IO流概述和分类" class="headerlink" title="IO流概述和分类"></a>IO流概述和分类</h5><p><img src="/2021/10/31/io-liu/image-20211031100640022.png" alt="IO流概述"><strong>IO流分类</strong></p><p><img src="/2021/10/31/io-liu/image-20211031100723536.png" alt="IO流分类"></p><p><img src="/2021/10/31/io-liu/image-20211031100848036.png" alt="选择"></p><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><h5 id="字节流写数据"><a href="#字节流写数据" class="headerlink" title="字节流写数据"></a>字节流写数据</h5><p>字节流抽象基类</p><p><img src="/2021/10/31/io-liu/image-20211031101032571.png" alt="字节流抽象基类"></p><p>FileOutStreram：文件输出流用于将数据写入File</p><p><img src="/2021/10/31/io-liu/image-20211031101920924.png" alt="image-20211031101920924"></p><p><img src="/2021/10/31/io-liu/image-20211031101938193.png" alt="image-20211031101938193"></p><h6 id="字节流写数据的三种方式"><a href="#字节流写数据的三种方式" class="headerlink" title="字节流写数据的三种方式"></a>字节流写数据的三种方式</h6><p><img src="/2021/10/31/io-liu/image-20211031102029224.png" alt="字节流 写数据"></p><h6 id="字节流写数据的两个小问题"><a href="#字节流写数据的两个小问题" class="headerlink" title="字节流写数据的两个小问题"></a>字节流写数据的两个小问题</h6><p><img src="/2021/10/31/io-liu/image-20211031103127841.png" alt="问题"></p><h6 id="字节流写数据的异常处理"><a href="#字节流写数据的异常处理" class="headerlink" title="字节流写数据的异常处理"></a>字节流写数据的异常处理</h6><p><img src="/2021/10/31/io-liu/image-20211031103323322.png" alt="异常处理"></p><h6 id="字节流读数据"><a href="#字节流读数据" class="headerlink" title="字节流读数据"></a>字节流读数据</h6><p><img src="/2021/10/31/io-liu/image-20211031103729228.png" alt="字节流读数据"></p><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><p><img src="/2021/10/31/io-liu/image-20211031152817279.png" alt="字节缓冲流"></p><p><img src="/2021/10/31/io-liu/image-20211031152841448.png" alt="构造方法"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><h6 id="为什么会出现字符流"><a href="#为什么会出现字符流" class="headerlink" title="为什么会出现字符流"></a>为什么会出现字符流</h6><p><img src="/2021/10/31/io-liu/image-20211031154007979.png" alt="为什么会出现字符流"></p><h6 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h6><p><img src="/2021/10/31/io-liu/image-20211031154320897.png" alt="Ascii字符集"></p><p><img src="/2021/10/31/io-liu/image-20211031154435274.png" alt="GBXXX字符集"></p><p><img src="/2021/10/31/io-liu/image-20211031154540524.png" alt="Unicode字符集"></p><h6 id="字符串中的编码解码问题"><a href="#字符串中的编码解码问题" class="headerlink" title="字符串中的编码解码问题"></a>字符串中的编码解码问题</h6><p><img src="/2021/10/31/io-liu/image-20211031154731573.png" alt="编码解码问题"></p><h6 id="字符流中的编码解码问题"><a href="#字符流中的编码解码问题" class="headerlink" title="字符流中的编码解码问题"></a>字符流中的编码解码问题</h6><p><img src="/2021/10/31/io-liu/image-20211031155147199.png" alt="字符流中的编码解码问题"></p><h6 id="字符流写数据的五种方式"><a href="#字符流写数据的五种方式" class="headerlink" title="字符流写数据的五种方式"></a>字符流写数据的五种方式</h6><p><img src="/2021/10/31/io-liu/image-20211031155938705.png" alt="字符流写数据"></p><h6 id="字符流读数据的两种方式"><a href="#字符流读数据的两种方式" class="headerlink" title="字符流读数据的两种方式"></a>字符流读数据的两种方式</h6><p><img src="/2021/10/31/io-liu/image-20211031161021810.png" alt="字符流读数据的两种方式"></p><p><img src="/2021/10/31/io-liu/image-20211031161823015.png" alt="复制文件"></p><h4 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h4><p><img src="/2021/10/31/io-liu/image-20211031162329437.png" alt="字符缓冲流"></p><h6 id="字符缓冲流特有功能"><a href="#字符缓冲流特有功能" class="headerlink" title="字符缓冲流特有功能"></a>字符缓冲流特有功能</h6><p><img src="/2021/10/31/io-liu/image-20211031163109781.png" alt="字符缓冲流特有功能"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> io流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2021/10/30/mybatisplus/"/>
      <url>/2021/10/30/mybatisplus/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis-Plus"></a>Mybatis-Plus</h1><h4 id="Mybatis-Plus介绍"><a href="#Mybatis-Plus介绍" class="headerlink" title="Mybatis-Plus介绍"></a>Mybatis-Plus介绍</h4><p>MybatisPlus(简称MP）是一个Mybatis的增强工具，在Mybatis的基础上只做增强不做改变，为简化开发，提高效率而生</p><p>官网：<a href="https://mybatis.plus/">https://mybatis.plus/</a> 或 <a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a></p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>无侵入</li><li>损耗小</li><li>强大的CRUD操作</li><li>．．．．</li></ul><p><img src="/2021/10/30/mybatisplus/image-20211030135042127.png" alt="特性"></p><ul><li>内置SQL注入剥离器：支持SQL注入剥离，防止SQL攻击</li></ul><h5 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h5><p><img src="/2021/10/30/mybatisplus/image-20211030155918848.png" alt="架构"></p><h4 id="mybatis-plus入门"><a href="#mybatis-plus入门" class="headerlink" title="mybatis-plus入门"></a>mybatis-plus入门</h4><h5 id="mybatis测试"><a href="#mybatis测试" class="headerlink" title="mybatis测试"></a>mybatis测试</h5><h5 id="创建数据库和表"><a href="#创建数据库和表" class="headerlink" title="创建数据库和表"></a>创建数据库和表</h5><p>创建数据库mp，utf-8编码</p><pre class="line-numbers language-db" data-language="db"><code class="language-db">-- 创建测试表CREATE TABLE `tb_user` (`id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',`user_name` varchar(20) NOT NULL COMMENT '用户名',`password` varchar(20) NOT NULL COMMENT '密码',`name` varchar(30) DEFAULT NULL COMMENT '姓名',`age` int(11) DEFAULT NULL COMMENT '年龄',`email` varchar(50) DEFAULT NULL COMMENT '邮箱',PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;-- 插入测试数据INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES('1', 'zhangsan', '123456', '张三', '18', 'test1@itcast.cn');INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES('2', 'lisi', '123456', '李四', '20', 'test2@itcast.cn');INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES('3', 'wangwu', '123456', '王五', '28', 'test3@itcast.cn');INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES('4', 'zhaoliu', '123456', '赵六', '21', 'test4@itcast.cn');INSERT INTO `tb_user` (`id`, `user_name`, `password`, `name`, `age`, `email`) VALUES('5', 'sunqi', '123456', '孙七', '24', 'test5@itcast.cn');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="项目导入"><a href="#项目导入" class="headerlink" title="项目导入"></a>项目导入</h5><p>新建maven项目，导入依赖</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token comment">&lt;!--mp--&gt;</span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.4.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.13.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.0.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>5.3.10<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.18.20<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>provided<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>slf4j-log4j12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.6.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建模块，继承夫项目</p><p>导入log4配置文件log4j.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">log4j.rootLogger</span><span class="token punctuation">=</span><span class="token attr-value">DEBUG,A1</span><span class="token attr-name">log4j.appender.A1</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.A1.layout</span><span class="token punctuation">=</span><span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.A1.layout.ConversionPattern</span><span class="token punctuation">=</span><span class="token attr-value">[%t] [%c]-[%p] %m%n</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>新建mybatis-config.xml配置文件</p><pre class="line-numbers language-XML" data-language="XML"><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;                &lt;property name="url" value="jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;allowMultiQueries=true&amp;useSSL=false"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="123456"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource="UserMapper.xml"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编写User类,位于Java.com.wang.pojo下</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">package com.wang.pojo;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@NoArgsConstructor@AllArgsConstructorpublic class User {    private Long id;    private  String userNmae;    private  String password;    private  String name;    private Integer age;    private String email;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在java.com.wang.mapper包下新建UserMapper接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>mapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span></span><span class="token class-name">User</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在resource下新建UserMapper.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">mapper</span>        <span class="token name">PUBLIC</span> <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>        <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wang.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>findAll<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.wang.pojo.User<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select * from tb_user    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新建测试类测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span></span><span class="token class-name">UserMapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span></span><span class="token class-name">User</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">Resources</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span><span class="token class-name">SqlSession</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span><span class="token class-name">SqlSessionFactory</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>session<span class="token punctuation">.</span></span><span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span></span><span class="token class-name">Test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">InputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> newtest <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">{</span>        <span class="token class-name">String</span> resource <span class="token operator">=</span> <span class="token string">"mybatis-config.xml"</span><span class="token punctuation">;</span>        <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSessionFactory</span> sqlSessionFactory <span class="token operator">=</span> <span class="token keyword">new</span>                <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">UserMapper</span> userMapper <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span><span class="token class-name">UserMapper</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">User</span> user <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="mybatis整和mybatis-plus"><a href="#mybatis整和mybatis-plus" class="headerlink" title="mybatis整和mybatis-plus"></a>mybatis整和mybatis-plus</h5><h6 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h6><p>mapper继承BaseMapper，将拥有了BaseMapper中的所有方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>mapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>core<span class="token punctuation">.</span>mapper<span class="token punctuation">.</span></span><span class="token class-name">BaseMapper</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>wang<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span></span><span class="token class-name">User</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token keyword">extends</span> <span class="token class-name">BaseMapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在User类中加上注解</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@TableName</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="第二步"><a href="#第二步" class="headerlink" title="第二步:"></a>第二步:</h6><p>使用MP中的MybatisSqlSessionFactoryBuilder进程构建：</p><h3 id="MP使用"><a href="#MP使用" class="headerlink" title="MP使用"></a>MP使用</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ul><li><p>insert()</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">;</span><span class="token comment">//插入一条数据，返回受影响的行数</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要设置ID自增长</span><span class="token comment">//在实体类中ID上添加注解,改变Id策略</span><span class="token annotation punctuation">@TableId</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">IdType</span><span class="token punctuation">.</span>AUTO<span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">Long</span> id <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>TableField注解使用</p><ul><li>对象中的属性与字段名不一致</li><li>对象中字段在表中不存在</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//第一种，属性名与字段名不同，</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"email"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">String</span> mail<span class="token punctuation">;</span><span class="token comment">//第二种,属性在表中不存在，插入时不考虑</span><span class="token annotation punctuation">@TableField</span><span class="token punctuation">(</span>exist <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">String</span> address<span class="token punctuation">;</span><span class="token comment">//查询时不返回此字段的值 **保护数据**</span><span class="token annotation punctuation">@TableFiels</span><span class="token punctuation">(</span>select <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><ul><li><p>根据Id更新</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span>set<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span><span class="token comment">//传递要更新的对象，mp根据id进行更新，返回改变条数</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>根据条件更新</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//设置要更新的额字段，更新时语句只会包含set 了的值</span><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//要更新的字段</span><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储更新条件的集合</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加入更新条件，传递值为字段名和值</span><span class="token comment">//传递要更新的内容和更新条件，返回改变的行数</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">,</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">UpdateWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UpdateWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span><span class="token string">"dqawwad"</span><span class="token punctuation">)</span><span class="token comment">//设置更新的字段</span>    <span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token comment">//设置更新的条件</span>    <span class="token comment">//传递要更新的内容和更新条件，返回改变的行数</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//update tb_user set age = ? ,password = ? where user_name = ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><ul><li><p>根据Id删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> userMaapper<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token number">9L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//9L：long类型的9</span><span class="token comment">//delete  from tb_user where id = ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>根据map删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据Map删除，返回改变行数</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMaapper<span class="token punctuation">.</span><span class="token function">deleteByMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//delete  from tb_user where user_name = ? and password = ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>delete(根据wrapper)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//存储条件的集合</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//加入条件，传递值为字段名和值</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMaapper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setuserNmae</span><span class="token punctuation">(</span><span class="token string">"dwa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//直接包装user</span><span class="token keyword">int</span> result <span class="token operator">=</span> userMaapper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//delete  from tb_user where user_name = ? and age = ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>根据Id批量删除</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> result <span class="token operator">=</span> usermapper<span class="token punctuation">.</span><span class="token function">deleteBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">10L</span><span class="token punctuation">,</span><span class="token number">11L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li><p>根据Id查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据<strong>Id批量查询</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectBatchIds</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">10L</span><span class="token punctuation">,</span><span class="token number">11L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据条件查询<strong>一条数据</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"user_name"</span><span class="token punctuation">,</span><span class="token string">"zhangsan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果超出一条会报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询数据的条数</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> count <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectCount</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>根据条件查询所有记录</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">,</span><span class="token string">"qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//wrapper.gt("age",23);年龄大于23</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//select ... from tb_user where email like ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>根据条件进行分页查询<br>mp配置类MybatisPlusConfig类，配置分页插件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> page <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Page</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//页码，每页数据数</span><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">,</span><span class="token string">"qq.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">IPage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> iPage <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectPage</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回值为Ipage</span>ipage<span class="token punctuation">.</span><span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//总条数</span>ipage<span class="token punctuation">.</span><span class="token function">getPages</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//总页数</span>ipage<span class="token punctuation">.</span><span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前页数</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> ipage<span class="token punctuation">.</span><span class="token function">getRecords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前页记录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>mapperLocations<br>MyBatis Mapper 所对应的 XML 文件位置，如果您在 Mapper 中有自定义方法（XML 中有自定义实现），需要进行 该配置，告诉 Mapper 所对应的 XML 文件位置。</p></li><li><p>allEq</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//设置条件</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"曹操"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// wrapper.allEq(params);</span><span class="token comment">//SELECT * FROM tb_user WHERE password IS NULL AND name = ? AND age = ?</span><span class="token comment">// wrapper.allEq(params,false); //SELECT * FROM tb_user WHERE name = ? AND age = ?</span><span class="token comment">// wrapper.allEq((k, v) -&gt; (k.equals("name") ||k.equals("age")),params);</span><span class="token comment">//SELECT * FROM tb_user WHERE name = ? AND age = ?</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基本比较操作</p><ul><li>eq   等于 =</li><li>ne  不等于 &lt;&gt;</li><li>gt    &gt;</li><li>ge   &gt;=</li><li>lt    &lt;</li><li>le   &lt;=</li><li>between   值1&lt;?&lt;值2<ul><li>betweeen 值1 and 值2</li></ul></li><li>notbetweeen  1&gt;?&lt;2<ul><li>not betweeen 值1 and 值2</li></ul></li><li>in </li><li>notin</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"password"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ge</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">in</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token string">"王五"</span><span class="token punctuation">,</span> <span class="token string">"赵六"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,user_name,password,name,age,email FROM tb_user WHERE password = ?AND age &gt;= ? AND name IN (?,?,?)</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模糊查询</p><ul><li>like<ul><li>like’%值%’</li></ul></li><li>notLike</li><li>likelLft</li><li>likeRight</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,user_name,password,name,age,email FROM tb_user WHERE name LIKE ?</span><span class="token comment">//Parameters: %曹%(String)</span>wrapper<span class="token punctuation">.</span><span class="token function">like</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"曹"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>排序</p><ul><li>orderBy</li><li>orderByAsc</li><li>orderByDesc</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,user_name,password,name,age,email FROM tb_user ORDER BY age DESC</span>wrapper<span class="token punctuation">.</span><span class="token function">orderByDesc</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>逻辑查询</p><ul><li>or</li><li>and</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,user_name,password,name,age,email FROM tb_user WHERE name = ? OR age = ?</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>select指定查询字段</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> wrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,name,age FROM tb_user WHERE name = ? OR age = ?</span>wrapper<span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>userMapper<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>wrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="ActiveRecord"><a href="#ActiveRecord" class="headerlink" title="ActiveRecord"></a>ActiveRecord</h3><h5 id="ActiveRecord介绍"><a href="#ActiveRecord介绍" class="headerlink" title="ActiveRecord介绍"></a>ActiveRecord介绍</h5><p>ActiveRecord(简称AR）也属于ORM（对象关系映射）层，由Rails最早提出，遵循标准的ORM模型：表映射到记录，记 录映射到对象，字段映射到对象属性。配合遵循的命名和配置惯例，能够很大程度的快速实现模型的操作，而 且简洁易懂。</p><h6 id="ActiveRecord的主要思想是："><a href="#ActiveRecord的主要思想是：" class="headerlink" title="ActiveRecord的主要思想是："></a>ActiveRecord的主要思想是：</h6><ul><li>每一个数据库表对应创建一个类，类的每一个对象实例对应于数据库中表的一行记录；通常表的每个字段 在类中都有相应的Field；</li><li>ActiveRecord同时负责把自己持久化，在ActiveRecord中封装了对数据库的访问，即CURD;；</li><li>ActiveRecord是一种领域模型(Domain Model)，封装了部分业务逻辑；</li></ul><h5 id="ActiveRecord入门"><a href="#ActiveRecord入门" class="headerlink" title="ActiveRecord入门"></a>ActiveRecord入门</h5><p>在MP中，开启AR非常简单，只需要将实体对象继承Model即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">IdType</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">TableField</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">TableId</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">TableName</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">com<span class="token punctuation">.</span>baomidou<span class="token punctuation">.</span>mybatisplus<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>activerecord<span class="token punctuation">.</span></span><span class="token class-name">Model</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">AllArgsConstructor</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">Data</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">lombok<span class="token punctuation">.</span></span><span class="token class-name">NoArgsConstructor</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">extends</span> <span class="token class-name">Model</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用:user类继承了Model,可以使用Model类的方法</p><ul><li><p>根据主键查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">2L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">User</span> user2 <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>新增数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"刘备"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span><span class="token string">"liubei"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setEmail</span><span class="token punctuation">(</span><span class="token string">"liubei@itcast.cn"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> insert <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//user的insert方法完成插入，返回是否成功</span><span class="token comment">//INSERT INTO tb_user ( user_name, password, name, age, email ) VALUES ( ?, ?, ?, ?, ? )</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>更新操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">8L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> update <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//UPDATE tb_user SET age=? WHERE id=?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">7L</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> delete <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">deleteById</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//DELETE FROM tb_user WHERE id=?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>根据条件查询</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> userQueryWrapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>userQueryWrapper<span class="token punctuation">.</span><span class="token function">le</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>userQueryWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//SELECT id,user_name,password,name,age,email FROM tb_user WHERE age &lt;= ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="mybatis-plus的插件机制"><a href="#mybatis-plus的插件机制" class="headerlink" title="mybatis-plus的插件机制"></a>mybatis-plus的插件机制</h3><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法 调用包括：</p><ol><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) </li><li>ParameterHandler (getParameterObject, setParameters) </li><li>ResultSetHandler (handleResultSets, handleOutputParameters) </li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ol><p>总体概括为：</p><ol><li> 拦截执行器的方法 </li><li> 拦截参数的处理</li><li> 拦截结果集的处理 </li><li> 拦截Sql语法构建的处理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> mybatisPlus </tag>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小本本</title>
      <link href="/2021/10/30/xiao-ben-ben/"/>
      <url>/2021/10/30/xiao-ben-ben/</url>
      
        <content type="html"><![CDATA[<h2 id="2021-10-30-02-00-00"><a href="#2021-10-30-02-00-00" class="headerlink" title="2021.10.30 02:00:00"></a>2021.10.30 02:00:00</h2><p>被挑衅，生气，记仇一次<span class="github-emoji"><span>🙅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f645.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="2021-11-17-16-49-00"><a href="#2021-11-17-16-49-00" class="headerlink" title="2021.11.17 16:49:00"></a>2021.11.17 16:49:00</h2><p>没什么事，闲着写一点<span class="github-emoji"><span>🐽</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f43d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> 小本本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/29/maven-xiang-mu-guan-li/"/>
      <url>/2021/10/29/maven-xiang-mu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="maven项目管理"><a href="#maven项目管理" class="headerlink" title="maven项目管理"></a>maven项目管理</h1><h3 id="maven简介"><a href="#maven简介" class="headerlink" title="maven简介"></a>maven简介</h3><h6 id="传统项目管理状态分析"><a href="#传统项目管理状态分析" class="headerlink" title="传统项目管理状态分析"></a><strong>传统项目管理状态分析</strong></h6><ul><li>jar包不统一，jar包不兼容</li><li>工程升级维护过程操作繁琐</li></ul><h6 id="maven是什么？"><a href="#maven是什么？" class="headerlink" title="maven是什么？"></a><strong>maven是什么？</strong></h6><ul><li>Maven的本质是一个项目管理工具，将项目开发和管理过程抽象成一个项目对象模型（POM）</li><li>POM（Project Object Model）：项目对象模型</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029093514585.png" alt="依赖管理与项目构建"></p><h6 id="maven的作用"><a href="#maven的作用" class="headerlink" title="maven的作用"></a><strong>maven的作用</strong></h6><ul><li>项目构建：提供标准的，跨平台的自动化项目构建方式</li><li>依赖管理：方便快捷的管理项目以来的资源（jar包），避免资源间的版本冲突问题</li><li>统一开发结构：提供标准的，统一的项目结构</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029093812437.png" alt="项目结构"></p><h4 id="maven的安装与配置"><a href="#maven的安装与配置" class="headerlink" title="maven的安装与配置"></a>maven的安装与配置</h4><h6 id="maven环境变量配置"><a href="#maven环境变量配置" class="headerlink" title="maven环境变量配置"></a>maven环境变量配置</h6><ul><li>依赖Java，需要配置JAVA_HOME</li><li>设置maven自身的运行环境，需要配置MAVEN_HOME</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029094527241.png" alt="maven配置"></p><p>在path配置</p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029094605918.png" alt="maven配置"></p><h4 id="maven基本概念"><a href="#maven基本概念" class="headerlink" title="maven基本概念"></a>maven基本概念</h4><h5 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h5><ul><li><p>仓库：用于存储资源，包含各种jar包<img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029095008922.png" alt="image-20211029095008922"></p></li><li><p>仓库分类</p><ul><li>本地仓库：自己电脑上存储资源的maven仓库，连接远程仓库获取资源</li><li>私服：公司或部门级的中央仓库。</li><li>中央仓库:maven维护的统一仓库，存储所有资源</li><li>私服的作用：<ul><li>保存具有版权的资源，包括购买或自主研发的jar（中央仓库的jar包都是开源的）</li><li>一定范围内资源共享，仅对内部开放，不对外共享</li></ul></li></ul></li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029095243998.png" alt="仓库"></p><h5 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h5><ul><li><p>坐标：用于定位仓库中资源的位置<br><a href="https://mvnrepository.com/">maven坐标查询</a></p></li><li><p>Maven坐标主要组成吧</p><ul><li>groupId： 定义当前Maven项目隶属 组织名称</li><li>artifactId： 定义当前Maven项目名称</li><li>version：定义当前版本号</li><li>socpe: 作用域</li><li><em>packaging：定义当前项目的打包方式</em></li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.13.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>作用：使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载交给机器完成</p></li></ul><p><strong>本地仓库配置</strong></p><p>conf\settings.xml中配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>localRepository</span><span class="token punctuation">&gt;</span></span>自己目录\mvn_repository<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>localRepository</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>远程仓库配置</strong></p><p>conf\settings.xml中配置阿里云镜像</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrors</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirror</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span>nexus-aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mirrorOf</span><span class="token punctuation">&gt;</span></span>central<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrorOf</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>Nexus aliyun<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span>      <span class="token comment">&lt;!--url地址--&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url</span><span class="token punctuation">&gt;</span></span>http://maven.aliyun.com/nexus/content/group/public<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirror</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mirrors</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>全局setting与用户setting</strong></p><p>在repository中放置用户setting</p><h4 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h4><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029102149515.png" alt="项目结构"></p><p>新建pom.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>project</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modelVersion</span><span class="token punctuation">&gt;</span></span>4.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modelVersion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.wang<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>Jedis-study<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.0-SNAPSHOT<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>project</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Maven项目构建命令"><a href="#Maven项目构建命令" class="headerlink" title="Maven项目构建命令                    "></a>Maven项目构建命令                    <img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029103314178.png" alt="位置"></h6><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029103306352.png" alt="image-20211029103306352"></p><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><h5 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置                                                            "></a>依赖配置                                                            <img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029110257090.png" alt="image-20211029110257090"></h5><ul><li><p>依赖指当前项目运行时需要的jar，一个项目可以由多个依赖</p></li><li><p>格式：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--所有依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体依赖--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token comment">&lt;!--组织Id--&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!--项目id</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!--依赖版本号</span>            <span class="token attr-name">&lt;version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h5><ul><li>依赖具有传递性<ul><li>直接依赖：当前项目中通过依赖配置建立起来的依赖关系</li><li>间接依赖：被访问的资源如果依赖其他资源，当前项目间接依赖其他资源</li><li><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029104428349.png" alt="依赖传递"></li></ul></li></ul><h6 id="依赖传递冲突问题"><a href="#依赖传递冲突问题" class="headerlink" title="依赖传递冲突问题"></a>依赖传递冲突问题</h6><ul><li>路径优先：当资源中出现相同的资源时，层级越深，优先度越低，层级越浅，优先度越高。</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的</li><li><em>特殊优先：当统计配置了相同资源的不同版本的，后配置的覆盖先配置的</em></li></ul><h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p>​                                                                    <img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029110233242.png" alt="image-20211029110233242">        </p><ul><li><p>以来的jar默认情况下可以在任意地方使用，可以通过scope标签设定其作用范围</p></li><li><p>作用范围：</p><ul><li>主程序范围有效(main文件夹范围内)</li><li>测试范围有效（test文件夹范围内） </li><li>是否参与打包（package指令范围内 ）</li></ul></li><li><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029105951616.png" alt="作用范围"></p></li></ul><h6 id="依赖范围传递性"><a href="#依赖范围传递性" class="headerlink" title="依赖范围传递性"></a>依赖范围传递性</h6><ul><li>带有依赖范围的资源在进行传递时，作用范围将受到影响</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029110131626.png" alt="依赖范围传递性"></p><h3 id="生命周期与插件"><a href="#生命周期与插件" class="headerlink" title="生命周期与插件"></a>生命周期与插件</h3><h5 id="项目构建生命周期"><a href="#项目构建生命周期" class="headerlink" title="项目构建生命周期                                         "></a>项目构建生命周期                                         <img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029141621858.png"></h5><ul><li>Maven构建生命周期描述的是一次构建过程经历了多少事件</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029141647867.png" alt="生命周期"></p><p>clean<strong>生命周期</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029141903904.png" alt="clean生命周期"></p><p><strong>default构建生命周期</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029142152527.png" alt="default构建生命周期"></p><p><strong>执行生命周期必须执行之前所有的过程</strong></p><p><strong>site构建生命周期</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029142028201.png" alt="site构建生命周期"></p><h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><ul><li>插件与生命周期内的阶段绑定，在执行道对应生命周期时执行对应的插件功能</li><li>默认Maven在各个生命周期上绑定有预设的功能</li><li>通过插件可以定义其他功能</li></ul><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029142606693.png" alt="插件"></p><h2 id="Maven高级"><a href="#Maven高级" class="headerlink" title="Maven高级"></a>Maven高级</h2><h5 id="工程模块与模块划分"><a href="#工程模块与模块划分" class="headerlink" title="工程模块与模块划分"></a>工程模块与模块划分</h5><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029143810905.png" alt="模块划分"></p><ul><li>新建模块</li><li>拷贝原始模块内容</li></ul><h5 id="模块聚合"><a href="#模块聚合" class="headerlink" title="模块聚合"></a>模块聚合</h5><p><strong>多模块构建维护</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029145241206.png" alt="模块管理"></p><ul><li><p>作用：聚合用于快速创建maven项目，一次性构建多个项目/模块。</p></li><li><p>制作方式：</p><ul><li><p>创建一个空模块，在pom.xml中打包类型定义为pom</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--定义该工程用于进行构建管理--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>定义当前模块进行构建操作时关联的其他模块的名称</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>modules</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>../ssm_controller<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>../ssm_service<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>../ssm_dao<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>module</span><span class="token punctuation">&gt;</span></span>../ssm_pojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>module</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>modules</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>注意事项：参与聚合操作的模块最终执行顺序与模块之间的依赖关系有关，与配置顺序无关</p></li></ul><h5 id="模块继承"><a href="#模块继承" class="headerlink" title="模块继承"></a>模块继承</h5><p><strong>模块依赖关系维护</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029151020306.png" alt="模块依赖关系"></p><p><strong>继承</strong></p><ul><li><p>声明依赖管理:在父工程中声明进行模块管理</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体的依赖--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependecies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependecy</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependecy</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependecy</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependecy</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependecies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>作用：通过继承可以实现在子工程中沿用父工程中的配置 </p><ul><li>Maven中的继承与java中的继承相似，在子工程中配置继承关系。</li><li>子工程中可以省去组织Id与版本号</li></ul></li><li><p>制作方式：</p><ul><li><p>在子工程中声明其父工程坐标与对应的位置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--定义该工程的父工程--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--父工程的组织ID--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--父工程的项目ID--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--父工程的pom文件--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">&gt;</span></span>路径/pom.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>继承依赖使用</strong>：在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependecies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependecy</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--不用定义版本号--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependecy</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependecies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>继承的资源</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029152155524.png" alt="继承的资源"></p><h5 id="继承与聚合"><a href="#继承与聚合" class="headerlink" title="继承与聚合"></a>继承与聚合</h5><ul><li>作用：<ul><li>聚合用于快速构建项目</li><li>继承用于快速配置</li></ul></li><li>相同点：<ul><li>聚合和继承的pom.xml文件打包方式均为pom，可以将两种关系制作在同一个pom文件中</li><li>聚合和继承均属于设计型模块，并无实际的模块内容</li></ul></li><li>不同点：<ul><li>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些</li><li>继承是在子模块中配置关系，父模块无法感知到哪些子模块继承了自己</li></ul></li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><strong>属性类别：</strong>    <img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029154736061.png" alt="属性类别"></p><h6 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h6><ul><li><p>作用</p><ul><li>等同于定义变量，方便统一维护</li></ul></li><li><p>定义格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>junit.version</span><span class="token punctuation">&gt;</span></span>4.12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>spring.version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>调用格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${junit.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h6 id="内置属性"><a href="#内置属性" class="headerlink" title="内置属性"></a>内置属性</h6><ul><li><p>作用：</p><ul><li>调用Maven内置属性，快捷配置</li></ul></li><li><p>调用格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">${version}${basedir}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h6 id="Setting属性"><a href="#Setting属性" class="headerlink" title="Setting属性"></a>Setting属性</h6><ul><li><p>作用：</p><ul><li>使用Maven 配置文件setting.xml中的标签属性，用于动态配置</li></ul></li><li><p>调用格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">${settings.localRepository}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="Java系统属性"><a href="#Java系统属性" class="headerlink" title="Java系统属性"></a>Java系统属性</h6><ul><li><p>作用：</p><ul><li>读取Java系统属性</li></ul></li><li><p>调用格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">${user.home}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>系统属性查询方式</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mvn help:system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="环境变量属性"><a href="#环境变量属性" class="headerlink" title="环境变量属性"></a>环境变量属性</h6><ul><li><p>作用：</p><ul><li>调用环境变量属性</li></ul></li><li><p>调用格式</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">${env.JAVA_HOME}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h5><p><strong>工程版本</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029155819364.png" alt="工程版本"></p><h5 id="资源配置"><a href="#资源配置" class="headerlink" title="资源配置"></a>资源配置</h5><p><strong>资源配置多文件维护</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029160308417.png" alt="文件维护"></p><h6 id="配置文件引用pom属性"><a href="#配置文件引用pom属性" class="headerlink" title="配置文件引用pom属性"></a>配置文件引用pom属性</h6><ul><li><p>作用</p><ul><li>在任意配置文件中加载pom文件中配置的<strong>属性</strong></li></ul></li><li><p>调用格式</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">${jdbc.url}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>开启配置文件加载pom属性</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resource</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--设置支持配置文件对应的位置目录，支持使用属性动态设定路径--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>directory</span><span class="token punctuation">&gt;</span></span>${project.basedir}/src/main/resources<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>directory</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filtering</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filtering</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resource</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="多环境开发配置"><a href="#多环境开发配置" class="headerlink" title="多环境开发配置"></a>多环境开发配置</h5><ul><li><p>作用</p><ul><li>配置多环境开发需要的配置文件</li></ul></li><li><p>配置</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--创建多环境--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!--具体环境--&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!--唯一id--&gt;</span>pro_env<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--专属环境属性值--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>jdbc.url</span><span class="token punctuation">&gt;</span></span>jdbc::mysql://127.0.0.1:3306/dbname<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>jdbc.url</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!--设置默认启动--&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">&gt;</span></span>   ......    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h6 id="加载指定环境"><a href="#加载指定环境" class="headerlink" title="加载指定环境"></a>加载指定环境</h6><ul><li><p>作用</p><ul><li>加载指定配置环境</li></ul></li><li><p>调用格式</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mvn 指令 -p 环境定义Idmvn install -p pro_env<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h5 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h5><p><strong>应用场景</strong></p><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029162748402.png" alt="应用场景"></p><h6 id="使用命令跳过测试"><a href="#使用命令跳过测试" class="headerlink" title="使用命令跳过测试"></a>使用命令跳过测试</h6><ul><li><p>命令</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mvn 指令 -D skipTests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意事项</p><ul><li>执行的指令生命周期必须包含测试环节</li></ul></li></ul><h6 id="使用界面操作方式跳过测试"><a href="#使用界面操作方式跳过测试" class="headerlink" title="使用界面操作方式跳过测试"></a>使用界面操作方式跳过测试</h6><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029164030895.png" alt="测试"></p><h6 id="使用配置跳过测试"><a href="#使用配置跳过测试" class="headerlink" title="使用配置跳过测试"></a>使用配置跳过测试</h6><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029164048833.png" alt="使用配置跳过测试"></p><h4 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h4><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029164222507.png" alt="分模块开发合作"></p><h5 id="Nexus"><a href="#Nexus" class="headerlink" title="Nexus"></a>Nexus</h5><ul><li><p>Nexus是Sonatype公司的一款Maven私服产品</p></li><li><p>下载地址：<a href="https://help.sonatype.com/repomanager3/download">https://help.sonatype.com/repomanager3/download</a></p></li><li><p>启动服务器（命令行启动）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nexus.exe /run nexus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>访问服务器（默认端口8081）</p><pre class="line-numbers language-none"><code class="language-none">http://localhost:8081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>修改基础配置信息</p><ul><li>安装路径下etc目录中nexus-default。properties文件中</li></ul></li><li><p>修改服务器运行配置信息</p><p>bin/nexus.vmoptions</p></li></ul><h6 id="仓库分类"><a href="#仓库分类" class="headerlink" title="仓库分类"></a>仓库分类</h6><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029165303999.png" alt="仓库分类"></p><h6 id="资源上传"><a href="#资源上传" class="headerlink" title="资源上传"></a>资源上传</h6><p><img src="/2021/10/29/maven-xiang-mu-guan-li/image-20211029165335633.png" alt="资源上传"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis集群</title>
      <link href="/2021/10/26/redis-ji-qun/"/>
      <url>/2021/10/26/redis-ji-qun/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h5 id="主从复制简介"><a href="#主从复制简介" class="headerlink" title="主从复制简介"></a>主从复制简介</h5><p>互联网三高架构：<strong>高并发</strong>，<strong>高性能</strong>，<strong>高可用</strong></p><p><strong>单机Redis的风险与问题</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211026195558889.png" alt="单机Redis的风险与问题"></p><p><strong>解决方法</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211026195639258.png" alt="解决方法"></p><h6 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a><strong>多台服务器连接方案</strong></h6><ul><li><p>提供数据方 : master<br>主服务器，主节点，主库<br>主客户端</p></li><li><p>接收数据方： slave<br>从服务器，从节点，从库<br>从客户端</p></li><li><p>需要解决的问题<br>数据同步</p></li><li><p>核心工作</p><p>master的数据复制到slave中</p></li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211026195941790.png" alt="多台服务器连接方案"></p><h6 id="主从复制详情"><a href="#主从复制详情" class="headerlink" title="主从复制详情"></a>主从复制详情</h6><p>主从复制即将master中的数据即时，有效的复制到slave中<br>特征：一个master可以拥有多个slave,一个slave只能对应一个master</p><p><strong>职责</strong></p><ul><li><p>master</p><ul><li>写数据</li><li>执行写操作，将出现变化的数据自动同步到slave</li><li>读数据(可忽略)</li></ul></li><li><p>salve</p><ul><li>读数据</li><li>写数据(禁止)</li></ul></li></ul><p><strong>高可用集群</strong></p><p>可以多层</p><p><img src="/2021/10/26/redis-ji-qun/image-20211026200704566.png" alt="高可用集群"></p><p><strong>主从复制的作用</strong></p><ul><li>读写分离：master写，slave读，提高服务器的读写负载能力</li><li>负载均衡：基于主从结构，读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redistribution服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复</li><li>数据冗余：当实现数据热备份，是持久化之外的一种数据冗余方式</li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案</li></ul><h5 id="主从复制工作流程"><a href="#主从复制工作流程" class="headerlink" title="主从复制工作流程"></a>主从复制工作流程</h5><p><strong>主从复制三个阶段</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211026201535102.png" alt="主从复制三个阶段"></p><h6 id="1-建立连接阶段"><a href="#1-建立连接阶段" class="headerlink" title="1.  建立连接阶段"></a>1.  建立连接阶段</h6><ol><li>设置master的地址和端口，保存master信息</li><li>建立socket连接</li><li>发送ping指令（定时器任务）</li><li>身份验证</li><li>发送slave端口信息</li></ol><p><img src="/2021/10/26/redis-ji-qun/image-20211027155155663.png" alt="建立连接阶段"></p><p><strong>主从连接(slave连接master)</strong></p><ul><li><p>方式一：客户端发送命令</p><pre class="line-numbers language-none"><code class="language-none">slaveof &lt;masterip&gt; &lt;masterport&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式二：启动服务器参数</p><pre class="line-numbers language-none"><code class="language-none">redis-server -slaveof  &lt;masterip&gt; &lt;masterport&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>方式三：服务器配置配置文件</p><pre class="line-numbers language-none"><code class="language-none">slaveof  &lt;masterip&gt; &lt;masterport&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/26/redis-ji-qun/image-20211027155536426.png" alt="系统信息"></p></li><li><p>主从断开连接，客户端发送指令</p><pre class="line-numbers language-none"><code class="language-none">slaveof no one<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>授权访问</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027160412076.png" alt="授权访问"></p><h6 id="2-数据同步阶段"><a href="#2-数据同步阶段" class="headerlink" title="2. 数据同步阶段"></a>2. 数据同步阶段</h6><ul><li>在slave初次连接master后，复制master中的所有数据达到slave</li><li>将slave的数据库状态更新成master当前的数据库状态</li></ul><p><strong>工作流程</strong></p><ol><li>请求同步数据</li><li>创建RDB同步数据</li><li>恢复RDB同步数据</li><li>请求部分同步数据(AOF)</li><li>恢复部分同步数据</li></ol><p><img src="/2021/10/26/redis-ji-qun/image-20211027161147920.png" alt="工作流程"></p><p><strong>状态</strong>：</p><ul><li>salve：具有master端全部数据，包含RDB过程接收的数据</li><li>master：保存slave当前数据同步的位置</li><li>总体：之间完成了数据克隆</li></ul><p><strong>数据同步阶段master说明</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027162053563.png" alt=" "></p><p><strong>数据同步阶段slave说明</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027162716124.png" alt="数据同步阶段slave说明"></p><h6 id="3-命令传播阶段"><a href="#3-命令传播阶段" class="headerlink" title="3.命令传播阶段"></a>3.命令传播阶段</h6><ul><li>当master数据库状态被修改时，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，同步的动作被称为命令传播</li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令</li></ul><p><strong>传播命令阶段的部分复制</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027163415812.png" alt="传播命令阶段的部分复制"></p><p>服务器运行<strong>id</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027163455122.png" alt="服务器运行id"></p><p><strong>复制缓存区</strong></p><ul><li><p>概念：复制缓冲区，又名复制积压缓冲区，是一个先进先出（FIFO ）的队列。用于存储服务器执行过的命令，每次传播命令，master都会将传播的命令记录瞎来，并复制在复制缓冲区。</p><ul><li>复制缓冲区默认数据存储空间大小是1M，由于存储空间大小是固定的，当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素就会被放进队列</li></ul></li><li><p>由来：每台服务器启动时，如果开启由AOF或被连接成为master节点时，即创建复制缓冲区</p></li><li><p>作用：用于保存master接收到的所有指令（仅影响数据变更的指令，如set，select）</p></li><li><p>数据来源： 当master接收到主客户端的指令时，除了执行指令行，会将该指令保存在缓冲区中</p></li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211027164350104.png" alt="复制缓冲区"></p><p><strong>主从服务器复制偏移量</strong>(offset)<br><img src="/2021/10/26/redis-ji-qun/image-20211027165204410.png" alt="主从服务器复制偏移量(offset)"></p><h6 id="4-数据同步-命令传播阶段工作流程"><a href="#4-数据同步-命令传播阶段工作流程" class="headerlink" title="4.数据同步+命令传播阶段工作流程"></a>4.数据同步+命令传播阶段工作流程</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211027171747578.png" alt="工作流程"></p><p><strong>心跳机制</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027171837528.png" alt="心跳机制"></p><p><strong>心跳阶段注意事项</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027172019576.png" alt="心跳阶段注意事项"></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027172344821.png" alt="完整工作流程"></p><h5 id="主从复制常见问题"><a href="#主从复制常见问题" class="headerlink" title="主从复制常见问题"></a>主从复制常见问题</h5><p><strong>频繁的全量复制问题</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027172523980.png" alt="频繁的全量复制"></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027172710392.png" alt="频繁的全量复制2"></p><p><strong>频繁的网络中断问题</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027173020136.png" alt="频繁的网络中断问题1"></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027173217281.png" alt="频繁的网络中断问题2"></p><p><strong>数据不一致问题</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027173251003.png" alt="数据不一致问题"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><h5 id="哨兵简介："><a href="#哨兵简介：" class="headerlink" title="哨兵简介："></a>哨兵简介：</h5><p>主机(master)宕机：</p><p><img src="/2021/10/26/redis-ji-qun/image-20211027192611741.png" alt="主机宕机"></p><p><strong>哨兵(sentinel)<strong>：哨兵是一个分布式系统，用于对主从结构中的每台服务器进行</strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master</p><h6 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h6><ul><li><strong>监控</strong>：不断的检查master和slave是否正常运行。<br>master存活检测，master与slave运行情况检测</li><li>通知(提醒): 当被监视的服务器出现问题时，向其他(哨兵间，客户端)发送通知</li><li><strong>自动故障转移</strong>：断开master与slave连接，选取一个slave作为master，将其他slave连接到新的吗stern，并告知客户端新的服务器地址</li><li><strong>注意</strong>:<br> 哨兵也是一台redis服务器，只是不提供数据服务<br>通常哨兵配置数量为单数</li></ul><h5 id="配置哨兵"><a href="#配置哨兵" class="headerlink" title="配置哨兵"></a>配置哨兵</h5><p><img src="/2021/10/26/redis-ji-qun/image-20211027193407159.png" alt="配置哨兵"></p><h5 id="哨兵工作原理"><a href="#哨兵工作原理" class="headerlink" title="哨兵工作原理"></a>哨兵工作原理</h5><p><strong>主从切换</strong></p><p>​    哨兵在进行主从切换过程中经历三个阶段</p><ul><li>监控</li><li>通知</li><li>故障转移</li></ul><h6 id="阶段一：监控阶段"><a href="#阶段一：监控阶段" class="headerlink" title="阶段一：监控阶段"></a>阶段一：监控阶段</h6><ul><li><p>用于同步各个节点的状态信息</p><ul><li><p>获取各个sentinel的状态(是否在线)</p></li><li><p>获取master的状态：</p><ul><li><p>master的属性：</p><pre class="line-numbers language-none"><code class="language-none">runid role:master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>各个slave的详细信息</p></li></ul></li><li><p>获取所有的slave的状态(根据master中的slave信息)：</p><ul><li><p>salve属性</p><pre class="line-numbers language-none"><code class="language-none">runidrole:slavemaster_host,master_portoffset...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211027201259474.png" alt="哨兵工作原理-阶段一"></p><h6 id="阶段二：通知阶段"><a href="#阶段二：通知阶段" class="headerlink" title="阶段二：通知阶段"></a>阶段二：通知阶段</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211027201427933.png" alt="阶段二"></p><h6 id="阶段三：故障转移阶段"><a href="#阶段三：故障转移阶段" class="headerlink" title="阶段三：故障转移阶段"></a>阶段三：故障转移阶段</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211027202227281.png" alt="image-20211027202227281"></p><p><img src="/2021/10/26/redis-ji-qun/image-20211027202306048.png" alt="image-20211027202306048"></p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h4 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h4><p> <img src="/2021/10/26/redis-ji-qun/image-20211028104154862.png" alt="现状问题"></p><h5 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h5><ul><li>集群就是使用网络将若干台计算机联通起来，并提供统一的管理方式，时期对外产生单机的服务效果</li></ul><h5 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h5><ul><li>分散 单台服务器的访问压力，实现负载均衡</li><li>分散单台服务器的存储压力，实现可扩展性</li><li>降低单台服务器宕机带来的业务灾难</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028104444673.png" alt="集群"></p><h4 id="Redistribution集群结构设计"><a href="#Redistribution集群结构设计" class="headerlink" title="Redistribution集群结构设计"></a>Redistribution集群结构设计</h4><h5 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h5><ul><li> 通过算法设计，计算出key 应该保存的位置</li><li>将所有的存储空间计划切割成16384份，每台主机保存一部分<br>每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放在对应的存储空间</li></ul><p><strong>槽</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028105023438.png" alt="槽"></p><ul><li>增强可扩展性</li><li>通过计算计算key所在槽位置</li></ul><p><strong>集群内部通讯设计</strong></p><ul><li>各个数据库相互通信，保存各个库中槽的编号数据</li><li>一次命中，直接返回‘</li><li>一次未命中，告知具体位置</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028105232063.png" alt="通信设计"></p><h4 id="CLuster集群结构搭建"><a href="#CLuster集群结构搭建" class="headerlink" title="CLuster集群结构搭建"></a>CLuster集群结构搭建</h4><h5 id="Cluster配置"><a href="#Cluster配置" class="headerlink" title="Cluster配置"></a>Cluster配置</h5><ul><li><p>设计加入cluster,成为其中的节点</p><pre class="line-numbers language-none"><code class="language-none">cluster-enabled yes|no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>Cluster配置文件名，该文件属于自动生成，仅用于快速查找并查询文件内容</p><pre class="line-numbers language-none"><code class="language-none">cluster-config-file &lt;filename&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>节点服务响应超时时间，用于判定该节点是否下线或切换为从节点</p><pre class="line-numbers language-none"><code class="language-none">cluster-node-tmeout &lt;milliseconds&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>master连接的slave最小数量</p><pre class="line-numbers language-none"><code class="language-none">cluster-migration-barrier &lt;count&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="企业级解决方案"><a href="#企业级解决方案" class="headerlink" title="企业级解决方案"></a>企业级解决方案</h3><h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><p><strong>服务器启动后快速宕机</strong></p><p><strong>问题排查</strong></p><ol><li>请求数量较高</li><li>主从之间数据吞吐量较大，数据同步操作频率较高</li></ol><p><strong>解决方案</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028163335480.png" alt="解决方案"></p><p><strong>总结</strong>:缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统，避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p><strong>数据库服务器崩溃</strong>（1）</p><p><img src="/2021/10/26/redis-ji-qun/image-20211028163704398.png" alt="数据库服务器崩溃1"></p><p><strong>问题排查</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028163737283.png" alt="问题排查"></p><p><strong>解决方案（道）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028163934634.png" alt="解决方案"></p><p><strong>解决方案（术）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164111227.png" alt="解决方案"></p><p><strong>总结</strong></p><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如果能有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整</p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164717058.png" alt="策略总结"></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>数据库服务器崩溃（2）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164801810.png" alt="服务器崩溃"></p><p><strong>问题排查</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164826121.png" alt="问题排查"></p><p><strong>问题分析</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164845301.png" alt="问题分析"></p><p><strong>解决方案（术）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028164907071.png" alt="解决方案"></p><p><strong>总结</strong></p><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中reids后u，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>数据库服务器崩溃（3）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028165517861.png" alt="数据库服务器崩溃"></p><p><strong>问题排查</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028165556078.png" alt="问题排查"></p><p><strong>问题分析</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028165615260.png" alt="问题分析"></p><p><strong>解决方案（术）</strong></p><p><img src="/2021/10/26/redis-ji-qun/image-20211028165724078.png" alt="解决方案"></p><p><strong>总结</strong></p><p>缓存击穿了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致数据库服务器造成压力，通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应多策略应该在临时预案防范方面多做文章。</p><p>无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p><h4 id="性能指标监控"><a href="#性能指标监控" class="headerlink" title="性能指标监控"></a>性能指标监控</h4><h5 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a><strong>监控指标</strong></h5><p><img src="/2021/10/26/redis-ji-qun/image-20211028171259736.png" alt="监控指标"></p><ul><li>性能指标：Performance</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028171410385.png" alt="performance"></p><ul><li>内存指标：Memory</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028171442353.png" alt="Memory"></p><ul><li>基本活动指标：basic activity</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028171530030.png" alt="basic activity"></p><ul><li>持久性指标：Persistence</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028171614591.png" alt="Persistence"></p><ul><li>错误指标：Error</li></ul><p><img src="/2021/10/26/redis-ji-qun/image-20211028171645237.png" alt="error"></p><h5 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h5><ul><li>工具<br><img src="/2021/10/26/redis-ji-qun/image-20211028171940767.png" alt="工具"></li><li>命令<br><img src="/2021/10/26/redis-ji-qun/image-20211028171957151.png" alt="命令"></li></ul><h6 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211028172124432.png" alt="benchmark"></p><h6 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211028172332220.png" alt="monitor"></p><h6 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h6><p><img src="/2021/10/26/redis-ji-qun/image-20211028172435718.png" alt="slowlog"></p>]]></content>
      
      
      
        <tags>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级</title>
      <link href="/2021/10/25/redis-gao-ji/"/>
      <url>/2021/10/25/redis-gao-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis高级"><a href="#Redis高级" class="headerlink" title="Redis高级"></a>Redis高级</h1><h2 id="liunx中Redi使用"><a href="#liunx中Redi使用" class="headerlink" title="liunx中Redi使用"></a>liunx中Redi使用</h2><ul><li><p>redis指定端口启动</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">redis-server --port 6379redis-cli -p 6379<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>可以进行多数据库使用，多端口设置，同时启动多个数据库</p></li><li><p>配置文件启动<br>redis.conf是redis的配置文件，新建配置文件redis-6379.conf，复制原文件，修改：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">daemonize  yes  //守护进程方式,日志会输出到日志文件logfile""//日志文件名称，dir   路径//生成文件位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">redis-server   redis-6379.conf (配置文件名)//通过配置文件启动<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>新建conf目录，用来你管理自己的配置文件</p></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><h4 id="持久-化介绍"><a href="#持久-化介绍" class="headerlink" title="持久 化介绍"></a>持久 化介绍</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><ul><li>Redis运行在内存上，数据容易丢失，需要持久化保存在硬盘上，防止数据丢失</li></ul><h5 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h5><ul><li>数据(快照)RDB：<br>将当前数据状态进行保存，快照形式，存储数据结果，存储格式简单，关注点在数据</li><li>过程(日志)：<br>将当前数据的操作过程进行保存，日志形式，存储操作过程，存储格式复杂，关注点在操作过程</li></ul><h4 id="RDB持久化详情"><a href="#RDB持久化详情" class="headerlink" title="RDB持久化详情"></a>RDB持久化详情</h4><h5 id="第一种RDB-启动方式"><a href="#第一种RDB-启动方式" class="headerlink" title="第一种RDB 启动方式"></a>第一种RDB 启动方式</h5><h6 id="命令启动"><a href="#命令启动" class="headerlink" title="命令启动"></a>命令启动</h6><ul><li>命令</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>作用:  </p><p>保存数据,生成rdb文件，将数据保存在文件中</p></li></ul><p><strong>在配置文件中修改</strong></p><ul><li><p>dbfilename  dump.rdb</p><p>说明：设置本地数据库文件名，默认为dump.rdb</p><p>经验：通常设置为dump-<strong>端口号</strong>.rdb</p></li><li><p>dir </p><p>说明：设置存储.rdb文件的路径。</p><p>经验：通常设置成储存空间较大的目录中，目录名为<strong>data</strong></p></li><li><p>rdbcompression yes<br>说明：设置存储至本地数据库时是否压缩数据，默认为yes ，采用LZF压</p><p>经验：通常默认为开启状态，如果设置为no,可以节省CPU运行时间，但会使存储的文件变大(巨大)</p></li><li><p>rdbchecksum yes<br>说明：设置是否进行RDB文件校验，该校验过程在读文件和写文件过程均进行</p><p>经验：通常默认为开启状态，如果设置为no，可以节约读写过程约10%时间消耗，但是存在一定的数据损坏风险</p></li></ul><h6 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h6><ul><li><p>启动时自动恢复数据<br>数据库自己读取数据文件，恢复数据</p></li><li><p>save工作原理</p><p>Redis 为单线程执行,执行save指令会阻塞当前服务器，直到RDB 过程完成，可能会造成长时间阻塞，不建议线上使用</p></li></ul><h5 id="第二种RDB-启动方式-后台启动"><a href="#第二种RDB-启动方式-后台启动" class="headerlink" title="第二种RDB 启动方式(后台启动)"></a>第二种RDB 启动方式(后台启动)</h5><ul><li><p>命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">bgsave<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>作用<br>手动给数据库发送命令，但不立即执行。空闲时间数据库进行处理</p></li><li><p>工作原理</p><p><img src="/2021/10/25/redis-gao-ji/image-20211025193733206.png" alt="工作原理"></p></li><li><p>注意<br>bgsave命令是支队save阻塞问题做的优化。Redis内部涉及到RDB操作都建议使用bgsave。</p></li><li><p>stop-writes-on-basave-error yes</p><p>说明：后台存储过程如果出现错误现象，是否停止操作</p><p>经验：通常默认为开启状态</p></li></ul><h5 id="第三种RDB-启动方式-配置启动"><a href="#第三种RDB-启动方式-配置启动" class="headerlink" title="第三种RDB 启动方式(配置启动)"></a>第三种RDB 启动方式(配置启动)</h5><ul><li><p>根据配置自动启动,在配置文件中配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">save second changes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>作用</p><pre><code>满足限定时间范围内key的变化数量达到指定数量即进行持久化</code></pre></li><li><p>参数<br>second：监控时间范围<br>changes：监控key的变化量</p></li><li><p>范例</p><pre class="line-numbers language-shel" data-language="shel"><code class="language-shel">save 900 1save 300 10save 60 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="RDB三种启动方式对比"><a href="#RDB三种启动方式对比" class="headerlink" title="RDB三种启动方式对比"></a>RDB三种启动方式对比</h5><p><img src="/2021/10/25/redis-gao-ji/image-20211025195756349.png" alt="RDB三种启动方式对比"></p><h6 id="RDB特殊启动方式"><a href="#RDB特殊启动方式" class="headerlink" title="RDB特殊启动方式"></a>RDB特殊启动方式</h6><ul><li><p>服务器运行过程中重启</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">debug reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关闭服务器是保存指定数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">shutdown save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h5><ul><li><p>优点</p><p><img src="/2021/10/25/redis-gao-ji/image-20211025200129180.png" alt="优点"></p></li><li><p>缺点<br><img src="/2021/10/25/redis-gao-ji/image-20211025200150998.png" alt="缺点"></p></li></ul><h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p><img src="/2021/10/25/redis-gao-ji/image-20211025220521099.png" alt="RDB的弊端"></p><ul><li><p>不记录全数据，仅记录部分数据</p></li><li><p>记录操作记录</p></li></ul><h5 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h5><ul><li>AOF(append only file )持久化： 以独立日志的方式记录每次命令，重启时再重新之幸福AOF文件中的命令，达到恢复数据的作用，</li><li>改记录数据为记录数据产生的过程</li><li>主要作用是解决了数据持久化你的实时型，目前 已经是Redis持久化的主流方式</li></ul><h5 id="AOF写数据"><a href="#AOF写数据" class="headerlink" title="AOF写数据"></a>AOF写数据</h5><p><img src="/2021/10/25/redis-gao-ji/image-20211025221148941.png" alt="AOF写数据过程"></p><h6 id="AOF写数据三种策略"><a href="#AOF写数据三种策略" class="headerlink" title="AOF写数据三种策略"></a>AOF写数据三种策略</h6><ul><li><p>always(每次)</p><pre><code>每次写入操作均同步到AOF文件中，**数据零误差，性能较低 不建议使用**</code></pre></li><li><p>everysec(每次)<br>每秒将缓冲区中的指令同步到AOF文件中，<strong>数据准确性较高，性能较高 是默认配置</strong><br>再系统宕机的情况下丢失一秒的数据</p></li><li><p>no(系统控制)、</p><p>由操作系统控制每次同步到AOF文件的周期，整体过程不可控</p></li></ul><h6 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h6><ul><li><p>配置</p><pre class="line-numbers language-none"><code class="language-none">appendonly yes|no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>作用<br>是否开启AOF默认持久化功能，默认为不开启</p></li><li><p>配置</p><pre class="line-numbers language-none"><code class="language-none">apppendfsync always|everysec|no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>作用<br>AOF写数据策略</p></li></ul><h6 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h6><p><img src="/2021/10/25/redis-gao-ji/image-20211025222553087.png" alt="AOF重写"></p><h6 id="AOF重写规则"><a href="#AOF重写规则" class="headerlink" title="AOF重写规则"></a>AOF重写规则</h6><ul><li><p>进程内已超时的数据不再写入文件</p></li><li><p>忽略无效指令，重写是使用进程内数据直接生成，这样新的AOF文件只保留最终数据的写入文件</p></li><li><p>对同一数据的多条写命令合并成一条命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">如 lpush list 1 a ,lpush list1 b -----&gt;lpush list1 a b<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为防止数据量过大造成客户端缓冲区溢出，对list,set,hash,zset等类型，每条指令最多写入64个元素</p></li></ul><h6 id="AOF自动重写触发条件设置"><a href="#AOF自动重写触发条件设置" class="headerlink" title="AOF自动重写触发条件设置"></a>AOF自动重写触发条件设置</h6><ul><li><p>自动重写触发条件设置</p><pre class="line-numbers language-none"><code class="language-none">auto-aof-rewrite-min-size  s ize//达到比较大小重写auto-aof-rewrite-percentage percent//重写百分比<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>自动重写触发对比参数</p><pre class="line-numbers language-none"><code class="language-none">aof_current_sizeaof_base_size<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>自动重写触发条件</p><p><img src="/2021/10/25/redis-gao-ji/image-20211025224108323.png" alt="自动重写触发条件"></p></li></ul><h6 id="AOF重写工作原理"><a href="#AOF重写工作原理" class="headerlink" title="AOF重写工作原理"></a>AOF重写工作原理</h6><p><img src="/2021/10/25/redis-gao-ji/image-20211025224856532.png" alt="AOF重写工作原理"></p><p><img src="/2021/10/25/redis-gao-ji/image-20211025225010472.png" alt="AOF重写工作原理"></p><h4 id="RDB与AOF区别"><a href="#RDB与AOF区别" class="headerlink" title="RDB与AOF区别"></a>RDB与AOF区别</h4><p><img src="/2021/10/25/redis-gao-ji/image-20211025225117159.png" alt="RDB vs AOF "></p><p><strong>RDB与AOF选择</strong></p><p><img src="/2021/10/25/redis-gao-ji/image-20211025225328795.png" alt="RDB与AOF选择"></p><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h5 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1.事务简介"></a>1.事务简介</h5><ul><li>​    redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体(一个队列).当执行时，一次性按照添加顺序依次执行，中途不会被打断或干扰</li><li>一个队列中，一次性，顺序性，排他性的执行局一系列命令</li></ul><h5 id="2-事务基本操作"><a href="#2-事务基本操作" class="headerlink" title="2.事务基本操作"></a>2.事务基本操作</h5><ul><li><p>开启事务: 设定事务的开启位置，此指令执行后，后续所有指令均加入到事务中</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">multi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>执行事务：设定事务的结束位置，同时执行事务，与multi成对出现，成对使用</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">exec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>事务工作流程</strong></p><p><img src="/2021/10/25/redis-gao-ji/image-20211026151843167.png" alt="事务工作流程"></p><p><img src="/2021/10/25/redis-gao-ji/image-20211026151920696.png" alt="事务工作流程2"></p><p><strong>事务注意事项</strong></p><p><img src="/2021/10/25/redis-gao-ji/image-20211026152105726.png" alt="事务注意事项"></p><p>​    已经执行完毕的命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</p><p><strong>手动进行事务回滚</strong></p><ul><li>记录操作过程中被影响的数据之前的状态<ul><li>单数据：string</li><li>多数据： hash,list,set,zset</li></ul></li><li>设置指令恢复所有的被修改的项、<ul><li>单数据：直接set(注意周边属性，例如时效)</li><li>多数据：修改对应值或整体克隆</li></ul></li></ul><h5 id="3-事务-锁"><a href="#3-事务-锁" class="headerlink" title="3.事务-锁"></a>3.事务-锁</h5><p>​    <strong>基于特定条件的事务操作-锁</strong></p><ul><li><p>对key添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">watch key1 [key2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>取消对所有key的监视</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">unwatch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>基于特定条件的事务执行-分布式锁</strong>（设计概念）</p><ul><li><p>使用setnx设置一个公共锁</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sentx lock-key value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>利用setnx，命令的返回值特征，有值则返回设置成功，无值则返回设置失败</p><ul><li>对于设置成功的，拥有控制权，进行下一步操作</li><li>设置失败的，不具有控制权，排队或等待</li></ul></li><li><p>操作完成删除公共锁</p><pre class="line-numbers language-none"><code class="language-none">del lock-key <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>释放锁，以供其他进程使用</p></li></ul><p><strong>分布式锁的死锁</strong></p><ul><li><p>由于多次加锁，可能出现加锁后未解锁，会出现死锁现象，其他用户无法使用，需要系统级保底方案</p></li><li><p>解决方案-加时效(到时效自动释放锁)</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">expire lock-key secondpexpire lock-key milliseconds<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="过期数据的删除策略"><a href="#过期数据的删除策略" class="headerlink" title="过期数据的删除策略"></a>过期数据的删除策略</h2><p><strong>redis中的数据特征</strong></p><p>redis是一种内存级数据库，所有的数据均被存放在内存中，内存中的数据可以通过TTL指令获取其状态</p><ul><li>XX：具有时效性的数据</li><li>-1：永久有效的数据</li><li>-2：<strong>已经过期的数据</strong>或被删除的数据或未被定义的</li></ul><h5 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h5><p><img src="/2021/10/25/redis-gao-ji/image-20211026160001175.png" alt="image-20211026160001175"></p><p><strong>目标：在内存占用和CPU占用之间寻找一种平衡</strong>。顾此失彼都会造成整体性能的下降，甚至引发服务器宕机或内存泄漏</p><h6 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h6><ul><li>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作</li><li>优点：节省内存，到时就删除，快速释放掉不必要的内存占用</li><li>缺点：CPU压力很大，无论CPU此时负载多高，均占用CPU，会影响redis服务器响应时间和指令你吞吐量</li><li>总结：用处理器性能换取存储空间(拿时间换空间)</li></ul><h6 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h6><ul><li>数据到达过期时间，不做处理，等下次访问数据时删除<ul><li>如果未过期，返回数据</li><li>如果已经过期，删除，返回不存在</li></ul></li><li>优点：节约CPU性能，发现必须删除的时候才删除</li><li>缺点：内存压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能(空间换时间)</li></ul><h6 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h6><img src="/2021/10/25/redis-gao-ji/image-20211026161605435.png" alt="定期删除" style="zoom:120%;"><ul><li>周期性轮询redis库中的有时效数据，采用随机抽查的策略，利用过期数据占比的方式控制删除频率</li><li>特定1：CPU性能占用设置有峰值，检测频率可自己设置</li><li>特定2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li><li>总结：周期性抽查内存空间(随机抽查，重点抽查)</li></ul><h6 id="删除策略对比"><a href="#删除策略对比" class="headerlink" title="删除策略对比"></a>删除策略对比</h6><p><img src="/2021/10/25/redis-gao-ji/image-20211026162142157.png" alt="删除策略对比"></p><h6 id="逐出算法"><a href="#逐出算法" class="headerlink" title="逐出算法"></a>逐出算法</h6><p><img src="/2021/10/25/redis-gao-ji/image-20211026162533027.png" alt="算法引出"></p><p><strong>影响数据逐出的相关配置</strong></p><ul><li><strong>最大可使用内存</strong>：<strong>maxmenory</strong><br>占用物理内存的比例，默认为0，表示不限制，生产环境中根据需求设定，通常设置在50%以上</li><li>每次<strong>选取待删除数据</strong>的个数：<strong>maxmenory-samples</strong><br>选取数据时并不会全全库扫描，导致严重的性能消耗，降低读写性能，因此采用随机获取数据的方式做为待检测删除的数据</li><li>删除策略：<strong>maxmerory -policy</strong><br>达到最大内存后的，对被挑选出来的数据进行删除的策略</li></ul><h6 id="逐出策略分类"><a href="#逐出策略分类" class="headerlink" title="逐出策略分类"></a>逐出策略分类</h6><p><img src="/2021/10/25/redis-gao-ji/image-20211026164422454.png" alt="逐出策略"></p><p>推荐：volatile-lru</p><pre class="line-numbers language-none"><code class="language-none">maxmemory-policy volatile-lru<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="服务器基础配置"><a href="#服务器基础配置" class="headerlink" title="服务器基础配置"></a>服务器基础配置</h2><h4 id="服务器设定"><a href="#服务器设定" class="headerlink" title="服务器设定"></a>服务器设定</h4><ul><li><p>设置服务器以守护进程的方式进行</p><pre class="line-numbers language-none"><code class="language-none">daemonize yse|no<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>绑定主机地址</p><pre class="line-numbers language-none"><code class="language-none">bind 127.0.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置服务器端口号</p><pre class="line-numbers language-none"><code class="language-none">port 6379<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置数据库数量</p><pre class="line-numbers language-none"><code class="language-none">databases 16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h6><ul><li><p>设置服务器以指定日志级别记录</p><pre class="line-numbers language-none"><code class="language-none">loglevel debug|verbose|notice|warning<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>日志记录文件名</p><pre class="line-numbers language-none"><code class="language-none">logfile 端口号.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>注意</strong>：日志级别开发期设置为verbose即可，生产环境中配置为notice，简化日志输出量，降低写日志IO的频率</p><h6 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h6><ul><li><p>设置同一时间最大客户端连接数，默认无限制。当客户端连接达到上限，Redis会关闭新的连接</p><pre class="line-numbers language-none"><code class="language-none">maxclients 0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>客户端闲置等待最大时长，达到最大值关闭连接，如需关闭该功能，设置为0</p><pre class="line-numbers language-\" data-language="\"><code class="language-\">timeout 300<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="多服务器快捷配置"><a href="#多服务器快捷配置" class="headerlink" title="多服务器快捷配置"></a>多服务器快捷配置</h6><ul><li><p>导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redis实例配置文件,便于维护</p><pre class="line-numbers language-none"><code class="language-none">include /path/server-端口号。conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="Redis-高级数据类型"><a href="#Redis-高级数据类型" class="headerlink" title="Redis 高级数据类型"></a>Redis 高级数据类型</h2><p>具有明显的模型特征，为解决具体的业务而生</p><h5 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h5><h6 id="bitmaps类型的基本操作"><a href="#bitmaps类型的基本操作" class="headerlink" title="bitmaps类型的基本操作"></a>bitmaps类型的基本操作</h6><ul><li><p>获取指定key对应偏移量上的bit值</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">getbit key offset<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0</p><pre class="line-numbers language-none"><code class="language-none">setbit key offset value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="bitmaps类型的扩展操作"><a href="#bitmaps类型的扩展操作" class="headerlink" title="bitmaps类型的扩展操作"></a>bitmaps类型的扩展操作</h6><ul><li><p>对指定key进行按位交，并，非，异或操作，并将结果保存到destkey中</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">bitop op destkey key1 [key2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>and :交</li><li>or : 并</li><li>not :非</li><li>xor : 异或</li></ul></li><li><p>统计指定key中1的数量<span class="github-emoji"><span>🐷</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">bitcount key [start end]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><p>统计不重复的数据的数量,应用于独立数据的统计</p><p><strong>统计原始</strong>UV</p><ul><li><p>原始方案：set</p><p>存储每个用户的ID</p></li><li><p>改进方案：Bitmaps<br>存储每个用户的状态(bit)</p></li><li><p>全新方案：HyperLogLog</p></li></ul><p>基数：<strong>基数是数据集去重后元素个数</strong></p><p><img src="/2021/10/25/redis-gao-ji/image-20211026192020297.png" alt="基数"></p><p>HyperLogLog是用来做基数统计的，运用了LogLog的算法</p><p><strong>LogLog算法</strong></p><p><img src="/2021/10/25/redis-gao-ji/image-20211026192143670.png" alt="LogLog算法"></p><h6 id="HyperLogLog的基本操作"><a href="#HyperLogLog的基本操作" class="headerlink" title="HyperLogLog的基本操作"></a>HyperLogLog的基本操作</h6><ul><li><p>添加数据</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">pfadd key element [element ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>统计数据</p><pre class="line-numbers language-none"><code class="language-none">pfcount key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>合并数据</p><pre class="line-numbers language-none"><code class="language-none">pfmerge destkey sourcekey [sourcekey ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>相关说明</strong></p><ul><li>用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据</li><li>核心是基数估算算法，最终值存在一定误差</li><li>误差范围：基数估计的结果是一个带有0。81%标准误差的近似值</li><li>消耗空间极小，每个HyperLogLog占用了12K的内存用于标记基数</li><li>不是一次分配12K内存，随着基数增加而增加</li><li>pfmerge命令合并后占用的存储空间为12K，无论之前数据量是多少</li></ul><h5 id="GEO"><a href="#GEO" class="headerlink" title="GEO"></a>GEO</h5><p>设置坐标点，计算坐标点的距离(二维)(经纬？)(估算)</p><h6 id="GEO的基本操作"><a href="#GEO的基本操作" class="headerlink" title="GEO的基本操作"></a>GEO的基本操作</h6><ul><li><p>添加坐标点</p><pre class="line-numbers language-none"><code class="language-none">geoadd key(容器) longitude(X) latitude(Y) member(地点) [longitude latitude member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取坐标点</p><pre class="line-numbers language-none"><code class="language-none">geopos key member [member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>计算坐标点距离</p><pre class="line-numbers language-none"><code class="language-none">geodist key member1 member2 [unit(单位)]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据坐标求范围内的数据</p><pre class="line-numbers language-none"><code class="language-none">georadius key longitude latitude radius(距离) m|km|ft|mi [withcoord] [withdist] [withhash] [count count]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>根据点求范围内数据</p><pre class="line-numbers language-none"><code class="language-none">georadiusbymember key member radius(距离) m|km|ft|mi(单位) [withcoord] [withdist(显示距离)] [withhash(显示坐标)] [count count]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取指定点对应的坐标hash值</p><pre class="line-numbers language-none"><code class="language-none">gechash  key member [member]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>这个部分结束了:happy:</p><p>下次见<span class="github-emoji"><span>🤚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f91a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jedis_study</title>
      <link href="/2021/10/24/jedis-study/"/>
      <url>/2021/10/24/jedis-study/</url>
      
        <content type="html"><![CDATA[<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><h3 id="Jedis简介"><a href="#Jedis简介" class="headerlink" title="Jedis简介"></a>Jedis简介</h3><p>jedis: Java语言连Redis数据库的工具</p><h3 id="Jedis使用"><a href="#Jedis使用" class="headerlink" title="Jedis使用"></a>Jedis使用</h3><h4 id="Jedis简单使用"><a href="#Jedis简单使用" class="headerlink" title="Jedis简单使用"></a>Jedis简单使用</h4><ol><li><p>导包</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.9.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编写代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//插入数据</span><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//1.连接Redis</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.操作Redis</span>        jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.关闭连接</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//获取数据</span><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//1.连接Redis</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.操作Redis</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.关闭连接</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/24/jedis-study/image-20211024220538551.png" alt="获取数据"></p></li></ol><h5 id="操作list数据类型"><a href="#操作list数据类型" class="headerlink" title="操作list数据类型"></a>操作list数据类型</h5><ol><li><p>代码展示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment">//1.连接Redis</span>       <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//2.操作Redis</span>       jedis<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span><span class="token string">"a1"</span><span class="token punctuation">,</span><span class="token string">"a2"</span><span class="token punctuation">,</span><span class="token string">"a3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       jedis<span class="token punctuation">.</span><span class="token function">rpush</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span><span class="token string">"b1"</span><span class="token punctuation">,</span><span class="token string">"b2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list1 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">lrange</span><span class="token punctuation">(</span><span class="token string">"list1"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> string <span class="token operator">:</span> list1<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">//3.关闭连接</span>       jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结果展示<br><img src="/2021/10/24/jedis-study/image-20211024221049216.png" alt="结果展示"></p></li></ol><h5 id="操作hash数据类型"><a href="#操作hash数据类型" class="headerlink" title="操作hash数据类型"></a>操作hash数据类型</h5><ol><li><p>代码展示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//1.连接Redis</span>        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.操作Redis</span>        jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"wang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">,</span><span class="token string">"address"</span><span class="token punctuation">,</span><span class="token string">"xian"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> hash1 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"hash1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hash1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.关闭连接</span>        jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结果展示<br><img src="/2021/10/24/jedis-study/image-20211024221552156.png" alt="结果展示-hash"></p></li></ol><h4 id="Jedis工具类"><a href="#Jedis工具类" class="headerlink" title="Jedis工具类"></a>Jedis工具类</h4><h5 id="基于连接池获取连接"><a href="#基于连接池获取连接" class="headerlink" title="基于连接池获取连接"></a>基于连接池获取连接</h5><ul><li><p>jedispool:Jedis提供的连接池技术<br>poolConfig: 连接池配置对象</p><p>host:reids 服务地址</p><p>port：redis服务端口号</p></li><li><p>代码展示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPool</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPoolConfig</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> jp<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token class-name">JedisPoolConfig</span> jpc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最大连接池数</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最大连接数</span>         jp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>jpc<span class="token punctuation">,</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Jedis</span> <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> jp<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>改进</p><p>建立redis.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">redis.host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token attr-name">redis.maxTotal</span><span class="token punctuation">=</span><span class="token attr-value">30</span><span class="token attr-name">redis.maxIdle</span><span class="token punctuation">=</span><span class="token attr-value">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPool</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPoolConfig</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ResourceBundle</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">JedisPool</span> jp<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment">//获取配置文件</span>        <span class="token class-name">ResourceBundle</span>  rb<span class="token operator">=</span> <span class="token class-name">ResourceBundle</span><span class="token punctuation">.</span><span class="token function">getBundle</span><span class="token punctuation">(</span><span class="token string">"redis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">JedisPoolConfig</span> jpc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxTotal</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.maxTotal"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最大连接数</span>        jpc<span class="token punctuation">.</span><span class="token function">setMaxIdle</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.maxIdle"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//最小连接数</span>         jp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span>jpc<span class="token punctuation">,</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.host"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>rb<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"redis.port"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Jedis</span> <span class="token function">getJedis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> jp<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
            <tag> Jedis </tag>
            
            <tag> nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-live-and-my-love</title>
      <link href="/2021/10/24/my-live-and-my-love/"/>
      <url>/2021/10/24/my-live-and-my-love/</url>
      
        <content type="html"><![CDATA[<ul><li><p>种一棵树最好的时间是十年前,其次是现在<span class="github-emoji"><span>🌳</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f333.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></li><li><p>0440fd603a45d44d2f6881007da28eda1fbe43521f3fcbd17c6de3cff6b2716b</p></li><li><p>伟大发现总是罕见的，一生有一次就很幸运了</p></li></ul><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p>《计算机网络原理》 《计算机通信原理》 《计算机操作系统》《计算机组成原理》 《数据结构与算法》</p><p>spring  springboot mysql  JVM! 设计模式？</p>]]></content>
      
      
      
        <tags>
            
            <tag> live-and-love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给懒懒炫耀一下</title>
      <link href="/2021/10/23/gei-lan-lan-xuan-yao-yi-xia/"/>
      <url>/2021/10/23/gei-lan-lan-xuan-yao-yi-xia/</url>
      
        <content type="html"><![CDATA[<h1 id="你看到的都是我想让你看到的"><a href="#你看到的都是我想让你看到的" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h1><h2 id="你看到的都是我想让你看到的-1"><a href="#你看到的都是我想让你看到的-1" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h2><h3 id="你看到的都是我想让你看到的-2"><a href="#你看到的都是我想让你看到的-2" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h3><h4 id="你看到的都是我想让你看到的-3"><a href="#你看到的都是我想让你看到的-3" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h4><h5 id="你看到的都是我想让你看到的-4"><a href="#你看到的都是我想让你看到的-4" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h5><h6 id="你看到的都是我想让你看到的-5"><a href="#你看到的都是我想让你看到的-5" class="headerlink" title="你看到的都是我想让你看到的"></a>你看到的都是我想让你看到的</h6><p>我发现了什么？</p><p>懒懒是<span class="github-emoji"><span>🐷</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f437.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐖</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f416.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      
        <tags>
            
            <tag> lanlan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git_study</title>
      <link href="/2021/10/23/git-do/"/>
      <url>/2021/10/23/git-do/</url>
      
        <content type="html"><![CDATA[<h1 id="Github使用"><a href="#Github使用" class="headerlink" title="Github使用"></a>Github使用</h1><h2 id="github文件区域"><a href="#github文件区域" class="headerlink" title="github文件区域"></a>github文件区域</h2><pre class="line-numbers language-none"><code class="language-none">1.工作区 workspace未跟踪与未暂存文件处于本区2.暂存区 index提交到仓库之前的缓存区3.仓库* 本地仓库* 远程仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GitHub文件状态"><a href="#GitHub文件状态" class="headerlink" title="GitHub文件状态"></a>GitHub文件状态</h2><pre><code>1.未跟踪 untracked    新创建一个文件，处于未跟踪状态，文件位于工作区。2.未暂存 unstaged    修改一个文件，处于未暂存状态，文件位于工作区。3.已暂存     为暂存与为跟踪文件初步提交变为已暂存4.已提交5.不需管理    创建 .gitingore文件，在其中说明不需管理的文件</code></pre><h2 id="GitHub常用命令"><a href="#GitHub常用命令" class="headerlink" title="GitHub常用命令"></a>GitHub常用命令</h2><pre><code>1. git init 初始化git仓库(*)2. git add 工作区文件提交到暂存区  状态：工作区 -&gt; 暂存区    add . :添加所有文件到暂存区    add 文件名 :提交单个文件(*)3. git commit  提交到仓库  暂存区 -&gt; 本地仓库    git commit -m "'说明/标记'"4. git status 查看状态(*)5. git log     打印提交记录(日志)    log --all 显示所有分支    log --pretty=oneline  将提交信息显示为一行    log --abbrey-commit 使得输出的commit更简短    log --graph 以图的方式显示(*)6.git reset --hard commitID(提交记录)  版本回退 还原以前版本7.git reflog 查看删除记录（回滚之后可以看到已经删除的提交记录，包含commit记录）</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre class="line-numbers language-none"><code class="language-none">为了进行协同开发时，各个用户开发之间互不影响。工作区只能为一个分支进行服务每个分区(*)- git branch   查看本地分支-git branch vv 详细信息(*)- git branch  name(分支名称)  创建新分支  (*)- git checkout name   切换分支(*)- git checkout -b name  切换并创建分支(*)- git merge name  合并提交分支，一个分支上的提交可以合并到另一个分支(*)- git branch -d name 删除分支，删除时做各种检查，只能删除其他分支，不能删除当前分支。、- git branch -D name 强制删除，不做检查<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="git远程仓库托管"><a href="#git远程仓库托管" class="headerlink" title="git远程仓库托管"></a>git远程仓库托管</h2><pre class="line-numbers language-none"><code class="language-none">- git config --global user.name username 用户名- git config --global user.email email 邮箱- ssh -keygen -t rsa 请求ssh密钥获取密钥后复制公钥到github,- cat ~/.ssh/id_rsa.pub 获取密钥- ssh -T git@github.com 验证是否连接成功<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <pre class="line-numbers language-none"><code class="language-none">- git remote add name(名称）"url(ssh)" 绑定远程仓库- git remote 查看远程仓库- git push [-f]  [--set--upstream] [远端名称[本地分支名][远端分支名]]- git push name（仓库名） name(分支名称) 推送本地分支到远程仓库-git push --set --upstream name（仓库名） name(分支名称) 推送本地分支到远程仓库并建立和远端分支的关联关系-f 强制执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><pre class="line-numbers language-none"><code class="language-none">- git clone <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>远程仓库地址 [目录] 将远程仓库克隆到本地</strong></p><h4 id="抓取"><a href="#抓取" class="headerlink" title="抓取"></a>抓取</h4><pre class="line-numbers language-none"><code class="language-none">- git fetch [remote name](远程) [branch name](分支)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​    <strong>将仓库中的更新都拉取到本地，但不会进行合并</strong></p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><pre class="line-numbers language-none"><code class="language-none">- git merge (remote_name)/(branch_name)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>合并本地分支和远程分支</strong></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><pre class="line-numbers language-none"><code class="language-none">- git pull [remote name] [branch name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将仓库中的修改都拉到本地并进行合并，等于  fetch + merge</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-study</title>
      <link href="/2021/10/23/redis-study/"/>
      <url>/2021/10/23/redis-study/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><h3 id="1-Redis基础"><a href="#1-Redis基础" class="headerlink" title="1.Redis基础"></a>1.Redis基础</h3><h5 id="1-1关系型数据库"><a href="#1-1关系型数据库" class="headerlink" title="1.1关系型数据库"></a>1.1关系型数据库</h5><p>​        关系型数据库：磁盘IO性能低下，数据关系复杂，扩展性差，不利于大规模集群</p><p>​        解决思路：</p><ul><li>降低磁盘IO次数 –&gt;内存存储</li><li>去除数据间关系  –&gt;不存储关系，仅存储数据</li></ul><h5 id="1-2非关系型数据库NOSQL"><a href="#1-2非关系型数据库NOSQL" class="headerlink" title="1.2非关系型数据库NOSQL"></a>1.2非关系型数据库NOSQL</h5><p>NoSQL： Not-Only-SQL (泛指非关系型的数据库)，作为关系型数据库的补冲</p><p>作用： 应对基于海量用户和海量数据前提下的数据处理关系</p><p>特征：</p><ul><li>可扩容，可伸缩</li><li>大数据下高性能</li><li>灵活的数据模型</li><li>高可用</li></ul><p>常见NoSQL数据库：</p><ul><li>Redis</li><li>MongDB</li><li>memcache</li><li>tair</li></ul><h5 id="1-3-Redis"><a href="#1-3-Redis" class="headerlink" title="1.3 Redis"></a>1.3 Redis</h5><p>概念: Redis是用C语言开发的一个开源的<strong>高性能键值对(key-value)数据库</strong></p><p>特征：</p><ol><li> 数据间没有必然的关联关系</li><li> 内部采用单线程机制进行工作</li><li> 高性能</li><li>多数据类型支持<ul><li>字符串类型         string</li><li>列表类型           list</li><li>散列类型           hash</li><li>集合类型           set</li><li>有序集合类型   sorted_set</li></ul></li><li> 持久化支持，可以进行数据灾难恢复</li></ol><p>应用：</p><ul><li>热点数据加速查询。</li><li>任务队列，如秒杀，抢购等。</li><li>即时信息查看，排行榜，统计信息等。</li><li>时效信息控制，如验证码。</li><li>分布式数据共享，如分布式架构中的session分离</li><li>消息队列</li><li>分布式锁</li></ul><h5 id="1-4-Redis的基本操作"><a href="#1-4-Redis的基本操作" class="headerlink" title="1.4 Redis的基本操作"></a>1.4 Redis的基本操作</h5><h6 id="a-命令行指令"><a href="#a-命令行指令" class="headerlink" title="a.命令行指令"></a>a.命令行指令</h6><ul><li><p>功能性命令<br>set  key value         存储数据</p><p>get key                     获取数据</p></li><li><p>清除屏幕信息<br>clear                         清除屏幕信息</p></li><li><p>帮助信息查询<br>help  get                   获取get帮助信息<br>help<br>help  set</p></li><li><p>退出<br>quit<br>exit</p></li></ul><h3 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2.Redis数据类型"></a>2.Redis数据类型</h3><ul><li>Redis本身是一个Map，其中的数据类型都是key-value 的形式存储</li><li>数据类型指的是存储的数据的类型，也是value部分的类型</li></ul><p><img src="/2021/10/23/redis-study/image-20211024095746173.png" alt="image-20211024095746173"></p><h5 id="2-1-String类型"><a href="#2-1-String类型" class="headerlink" title="2.1 String类型"></a>2.1 String类型</h5><ul><li>存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据类型。</li><li>存储数据的格式：一个存储空间保存一个数据</li><li>存储内容： 通常使用字符串，如果以整数的形式表示，可以作为数字操作使用</li></ul><h6 id="String类型数据的基本操作"><a href="#String类型数据的基本操作" class="headerlink" title="String类型数据的基本操作"></a>String类型数据的基本操作</h6><ul><li><p>添加/修改数据</p><pre class="line-numbers language-none"><code class="language-none">set key value <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据</p><pre class="line-numbers language-none"><code class="language-none">get key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除数据</p><pre class="line-numbers language-none"><code class="language-none">del key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><img src="/2021/10/23/redis-study/image-20211024100337922.png" alt="image-20211024100337922"></p><ul><li><p>添加/修改多个数据</p><pre class="line-numbers language-none"><code class="language-none">mset key1 value1 key2 value2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取多个数据</p><pre class="line-numbers language-none"><code class="language-none">mget key1 key2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据字符个数(字符串长度)</p><pre class="line-numbers language-none"><code class="language-none">strlen key <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>追加信息到原始信息后部(如果原始信息在就追加,没有就新建)</p><pre class="line-numbers language-none"><code class="language-none">apppend key vaklue <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><img src="/2021/10/23/redis-study/image-20211024100903392.png" alt="image-20211024100903392"></p><p><strong>单指令，多指令数据操作选择</strong></p><p><img src="/2021/10/23/redis-study/image-20211024101533114.png" alt="image-20211024101533114"></p><h6 id="String-类型数据的扩展操作"><a href="#String-类型数据的扩展操作" class="headerlink" title="String  类型数据的扩展操作"></a><strong>String  类型数据的扩展操作</strong></h6><p>数据需为整数型/浮点型进行操作</p><ul><li><p>设置数值数据增加指定范围的值</p><pre class="line-numbers language-none"><code class="language-none">incr key incrby key incrementincrbyfloat key increament<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>设置数值数据减少指定范围的值</p><pre class="line-numbers language-none"><code class="language-none">decr key decrby key increment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024102414465.png" alt="image-20211024102414465"></p></li><li><p>设置数据具有指定的生命周期</p><pre class="line-numbers language-none"><code class="language-none">setex ley seconds value psetex key milliseconds value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>秒/毫秒，赋予数据生命周期，时间到即失效，适用于具有生命周期的项目</p></li></ul><p><img src="/2021/10/23/redis-study/image-20211024103422749.png" alt="image-20211024103422749"></p><p><strong>String类型数据操作的注意事项</strong></p><p><img src="/2021/10/23/redis-study/image-20211024103655991.png" alt="image-20211024103655991"></p><p><strong>key的设置约定</strong></p><p><img src="/2021/10/23/redis-study/image-20211024104202645.png" alt="image-20211024104202645"></p><h5 id="2-2-hash类型"><a href="#2-2-hash类型" class="headerlink" title="2.2 hash类型"></a>2.2 hash类型</h5><p><strong>存储的困惑</strong></p><p><img src="/2021/10/23/redis-study/image-20211024104437831.png" alt="image-20211024104437831"></p><ul><li>存储形式： key-value(field1value1 field2 value2 )，一个储存空间保存多个键值对3</li><li>hash类型： 底层使用hash表实现数据存储<br>如果field数量较少，存储结构优化为类数组结构<br>如果filed数量较多，存储结构使用HashMap结构</li></ul><h6 id="hash类型数据的基本操作"><a href="#hash类型数据的基本操作" class="headerlink" title="hash类型数据的基本操作"></a>hash类型数据的基本操作</h6><ul><li><p>添加/修改数据</p><pre class="line-numbers language-none"><code class="language-none">hset key field value <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取数据</p><pre class="line-numbers language-none"><code class="language-none">hget key fieldhgetall key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除数据</p><pre class="line-numbers language-none"><code class="language-none">hdel key field1 [field2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024105357611.png" alt="image-20211024105357611"></p></li><li><p>添加/修改多个数据</p><pre class="line-numbers language-none"><code class="language-none">hmset key field1 value1 field2 value2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取多个数据</p><pre class="line-numbers language-none"><code class="language-none">hmget key field1 field2 ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取哈希表中字段的数量</p><pre class="line-numbers language-none"><code class="language-none">hlen key <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取哈希表中是否存在指定的字段</p><pre class="line-numbers language-none"><code class="language-none">hexists key field<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024105854308.png" alt="image-20211024105854308"></p></li></ul><h6 id="hash类型数据库扩展操作"><a href="#hash类型数据库扩展操作" class="headerlink" title="hash类型数据库扩展操作"></a>hash类型数据库扩展操作</h6><ul><li><p>获取哈希表中所有的字段名或字段值</p><pre class="line-numbers language-none"><code class="language-none">hkeys key hvals key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>设置指定字段的数值数据增加指定范围的值</p><pre class="line-numbers language-none"><code class="language-none">hincrby key field incrementhincrbyfloat key field increment<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024110251097.png" alt="hash"></p></li><li><p>保存field前判断，有则不变，无则添加</p><pre class="line-numbers language-none"><code class="language-none">hsetnx key field v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>注意事项</strong></p><p><img src="/2021/10/23/redis-study/image-20211024110442137.png" alt="注意事项"></p><h5 id="2-3-List类型"><a href="#2-3-List类型" class="headerlink" title="2.3 List类型"></a>2.3 List类型</h5><ul><li>数据储存需求： 存储多个数据，并对数据进入存储空间的顺序进行区分</li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入数据</li><li>list类型： 保存多个数据，底层使用双向链表存储结构实现</li></ul><p><img src="/2021/10/23/redis-study/image-20211024143949025.png" alt="双向链表"></p><h6 id="list数据类型基本操作"><a href="#list数据类型基本操作" class="headerlink" title="list数据类型基本操作"></a>list数据类型基本操作</h6><h6 id=""><a href="#" class="headerlink" title=""></a></h6><ul><li><p>添加/修改数据</p><pre class="line-numbers language-none"><code class="language-none">lpush key value1 [value2] ...rpush key value1 [value2] ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取数据</p><pre class="line-numbers language-none"><code class="language-none">lrange key strat stoplindex key indexllen key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>获取并移除数据</p><pre class="line-numbers language-none"><code class="language-none">lpop keyrpop key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024145009483.png" alt="list基本操作"></p></li></ul><h6 id="list数据类型扩展操作"><a href="#list数据类型扩展操作" class="headerlink" title="list数据类型扩展操作"></a>list数据类型扩展操作</h6><ul><li><p>规定时间内获取并移除数据（阻塞式数据获取）</p><pre class="line-numbers language-none"><code class="language-none">blpop key1 [key2] timeout(时间)brpop key1 [key2] timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在等待时间内获取指定list（可以多个）中数据    并移除数据<br>等待时间结束有数据就取出来，没有为nil</p></li><li><p>移除指定数据 </p><pre class="line-numbers language-none"><code class="language-none">lrem key count value<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>redis 应用于具有操作先后顺序的数据控制</li></ul><p><img src="/2021/10/23/redis-study/image-20211024150705698.png" alt="移除指定数据"></p></li></ul><p>list<strong>类型数据操作注意事项</strong></p><p><img src="/2021/10/23/redis-study/image-20211024151239326.png" alt="list类型数据操作注意事项"></p><h5 id="2-4-set类型"><a href="#2-4-set类型" class="headerlink" title="2.4 set类型"></a>2.4 set类型</h5><ul><li>新的存储需求：存储大量的数据，在查询方面提供更高的效率</li><li>需要的内存结构： 能够保存大量的数据，高效的内部存储机制，便于查询</li><li>set类型：与hash存储结构完全相同，仅存储键，不存储值（nil)，并且值是不允许重复的</li></ul><p><img src="/2021/10/23/redis-study/image-20211024152502163.png" alt="set结构"></p><ul><li>解：将原本的value存储到hash结构的key上.</li></ul><h6 id="set数据类型基本操作"><a href="#set数据类型基本操作" class="headerlink" title="set数据类型基本操作"></a>set数据类型基本操作</h6><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><ul><li><p>添加数据</p><pre class="line-numbers language-none"><code class="language-none">sadd key member1 [member2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取全部数据</p><pre class="line-numbers language-none"><code class="language-none">smembers key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-none"><code class="language-none">srem key member1 [member2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024153004958.png" alt="set基本操作"></p></li><li><p>获取集合数据总量</p><pre class="line-numbers language-none"><code class="language-none">scard key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>判断集合中是否包含指定数据</p><pre class="line-numbers language-none"><code class="language-none">sismember key member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024153451228.png" alt="set基本操作2"></p></li></ul><h6 id="set数据类型扩展操作"><a href="#set数据类型扩展操作" class="headerlink" title="set数据类型扩展操作"></a>set数据类型扩展操作</h6><ul><li><p>随机获取集合中指定数量的数据</p><pre class="line-numbers language-none"><code class="language-none">srandmember key [count]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>随机获取集合中某个数据并移出集合</p><pre class="line-numbers language-none"><code class="language-none">spop key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024154110814.png" alt="set扩展操作"></p></li><li><p>求两个集合的交，并，差集</p><pre class="line-numbers language-none"><code class="language-none">sinter key1 key2sunion key1 key2sdiff key1 key2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024154800261.png" alt="set扩展操作"></p></li><li><p>求两个集合的交，并，差集并存储到指定集合中</p><pre class="line-numbers language-none"><code class="language-none">sinterstore destination key1 key2sunionstore destination key1 key2sdiffstore destination key1 key2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p><img src="/2021/10/23/redis-study/image-20211024155031844.png" alt="扩展操作3"></p><ul><li><p>将指定数据从原始集合中移动到目标集合中</p><pre class="line-numbers language-none"><code class="language-none">smove source destination member<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024155517114.png" alt="set扩展操作"></p></li></ul><p><strong>set类型数据操作的注意事项</strong></p><p><img src="/2021/10/23/redis-study/image-20211024155742644.png" alt="set注意事项"></p><h5 id="2-5-sorted-set类型"><a href="#2-5-sorted-set类型" class="headerlink" title="2.5 sorted_set类型"></a>2.5 sorted_set类型</h5><ul><li>新的存储需求： 数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行排序的方式</li><li>需要新的数据结构： 新的存储模型，可以保存可排序的数据</li><li>sorted_set 字段： 在set 的存储结构基础上添加可排序字段</li></ul><p><img src="/2021/10/23/redis-study/image-20211024161937437.png" alt="sorted_set类型"></p><h6 id="sorted-set数据类型基本操作"><a href="#sorted-set数据类型基本操作" class="headerlink" title="sorted_set数据类型基本操作"></a>sorted_set数据类型基本操作</h6><ul><li><p>添加数据</p><pre class="line-numbers language-none"><code class="language-none">zadd key sorce1(排序字段) member1 [sorce2 member2]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取全部数据(正序/逆序)</p><pre class="line-numbers language-none"><code class="language-none">zrange key start stop [withscores]zrevrange key start stop [withscores]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>删除数据</p><pre class="line-numbers language-none"><code class="language-none">zren key member [member ...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024162630099.png" alt="sorted_set类型基本操作"></p></li><li><p>按条件获取数据</p><pre class="line-numbers language-none"><code class="language-none">zrangebyscore key min max [withscores] [limit]zrevrangebyscore key max min [withscores]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>按条件删除数据</p><pre class="line-numbers language-none"><code class="language-none">zremrangebyrank key strat stopzremrangebyscore key min max  # max &gt;score &gt;min<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取集合数据总量</p><pre class="line-numbers language-none"><code class="language-none">zcard keyzcount key min max<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>集合交，并操作</p><pre class="line-numbers language-none"><code class="language-none">zinterstore destination numkeys(集合个数) key [key ...]zunionstore destination numkeys key [key ...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>合并后value相同的值，score会相加，新集合再进行排序</p></li></ul><h6 id="sorted-set类型数据扩展操作"><a href="#sorted-set类型数据扩展操作" class="headerlink" title="sorted_set类型数据扩展操作"></a>sorted_set类型数据扩展操作</h6><ul><li><p>获取数据对应的索引</p><pre class="line-numbers language-none"><code class="language-none">zrank key memberzrevrank key member<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>score值获取与修改</p><pre class="line-numbers language-none"><code class="language-none">zscore key memberzincrby key increment member<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p><strong>sorted_set类型数据操作的注意事项</strong></p><p><img src="/2021/10/23/redis-study/image-20211024171018363.png" alt="sorted_set类型数据操作的注意事项"></p><h5 id="2-6-通用命令"><a href="#2-6-通用命令" class="headerlink" title="2.6 通用命令"></a>2.6 通用命令</h5><h6 id="key通用操作"><a href="#key通用操作" class="headerlink" title="key通用操作"></a>key通用操作</h6><p>key特征： key 是一个字符串，通过key获取热Redis中保存的数据</p><ul><li><p>删除指定key</p><pre class="line-numbers language-none"><code class="language-none">del key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取key 是否存在</p><pre class="line-numbers language-none"><code class="language-none">exists key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取key的类型</p><pre class="line-numbers language-none"><code class="language-none">type key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="key扩展操作"><a href="#key扩展操作" class="headerlink" title="key扩展操作"></a>key扩展操作</h6><ul><li><p>为指定key设置有效期</p><pre class="line-numbers language-none"><code class="language-none">expire key secondspexpire key milliseconds(毫秒)expireat key timeout(时间戳)pexpireat key millisecons-timeout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取key的有效时间</p><pre class="line-numbers language-none"><code class="language-none">ttl keypttl key(时间戳)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>切换key从时效性转换为永久性</p><pre class="line-numbers language-none"><code class="language-none">persist key<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h6 id="key查询操作"><a href="#key查询操作" class="headerlink" title="key查询操作"></a>key查询操作</h6><ul><li><p>查询key</p><pre class="line-numbers language-none"><code class="language-none">keys pattern(*  ?   [])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/2021/10/23/redis-study/image-20211024202113015.png" alt="查询模式规则"></p></li></ul><h6 id="key其他操作"><a href="#key其他操作" class="headerlink" title="key其他操作"></a>key其他操作</h6><ul><li><p>key改名</p><pre class="line-numbers language-none"><code class="language-none">rename key newkey(如果newkey存在，则覆盖)renamenx key newkey(newkey不存在的情况下)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>为所有key进行排序</p><pre class="line-numbers language-none"><code class="language-none">sort<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>其他key通用操作</p><pre class="line-numbers language-none"><code class="language-none">help @generic<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h5 id="db通用指令"><a href="#db通用指令" class="headerlink" title="db通用指令"></a>db通用指令</h5><h6 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h6><p>redis提供16个数据库，每个数据库之间相互独立</p><ul><li><p>切换数据库</p><pre class="line-numbers language-none"><code class="language-none">select index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>其他操作</p><pre class="line-numbers language-none"><code class="language-none">quitping (测试服务器) pongecho message(输出日志)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>移动操作</p><pre class="line-numbers language-none"><code class="language-none">move key db   (剪切)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>数据清除</p><pre class="line-numbers language-none"><code class="language-none">dbsize   (查看数据数量)flushdb  (删除当前库数据)flushall  (删除所有库数据)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="解决方案列表"><a href="#解决方案列表" class="headerlink" title="解决方案列表"></a>解决方案列表</h4><p><img src="/2021/10/23/redis-study/image-20211024201016662.png" alt="解决方案列表"></p><h3 id="Jeids"><a href="#Jeids" class="headerlink" title="Jeids"></a>Jeids</h3>]]></content>
      
      
      
        <tags>
            
            <tag> nosql </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
